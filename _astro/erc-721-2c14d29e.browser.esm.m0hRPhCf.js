import{F as st,D as N,a as it,b as P,g as I,u as V}from"./QueryParams-c7566bb2.browser.esm.6S__dBaR.js";import{aS as ct,s as k,J as W,t as p,T as h,aT as M,B as f,aU as $,aV as Q,aW as Y,aX as F,aY as J,aZ as G,a1 as x,a_ as L,a$ as H,b0 as j,b1 as K,P as X,b2 as q,aw as ot,ay as pt,b3 as dt,a9 as A,b4 as O,aa as R,ab as D,ai as tt,K as v,q as rt,b5 as lt,aH as ht,b6 as ut,b7 as mt,ax as z,aG as gt,b8 as yt,b9 as Wt}from"./Login.kXXM0ZeX.js";import{a as y}from"./assertEnabled-55070897.browser.esm.GpoZczbg.js";import{h as T,d as l,C as Tt}from"./contract-appuri-a05d1c9a.browser.esm.Klf82i5D.js";import{D as wt}from"./drop-claim-conditions-b44061c8.browser.esm.n6oXxWS-.js";import{c as ft,D as Et}from"./contract-owner-87f50baf.browser.esm.kNfwp7uM.js";import{B as Ct,C as Z,s as _}from"./setErc20Allowance-832742d0.browser.esm.5FZ1S9fi.js";import{j as bt,k as St,m as It,o as Mt,B as At}from"./index.O_CxpveW.js";class kt{featureName=Y.name;constructor(t){this.contractWrapper=t}token=p(async t=>h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[t]}))}class vt{featureName=H.name;constructor(t,r,a){this.erc721=t,this.contractWrapper=r,this.storage=a;const e=new Tt(this.contractWrapper,pt,this.storage);this.conditions=new wt(this.contractWrapper,e,this.storage)}to=p(async(t,r,a)=>{const e=await this.conditions.getClaimTransaction(t,r,a);return e.setParse(n=>{const i=this.contractWrapper.parseLogs("TokensClaimed",n?.logs)[0].args.startTokenId,o=i.add(r),d=[];for(let c=i;c.lt(o);c=c.add(1))d.push({id:c,receipt:n,data:()=>this.erc721.get(c)});return d}),e})}function Nt(u){return lt(ht.parse(u))}class Pt{featureName=dt.name;constructor(t,r){this.erc721=t,this.contractWrapper=r}to=p(async(t,r,a)=>{const e=await this.contractWrapper.getSigner()?.getAddress();if(t!==e)throw new Error("Zora Drop: Destination address must match connected wallet address");if(a?.pricePerToken)throw new Error("Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated");const s=(await this.getSaleDetails()).publicSalePrice,i=Nt("0.000777"),o=f.from(s).add(i).mul(r),d=h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"purchase",args:[r],overrides:{value:o}});return d.setParse(c=>{const g=this.contractWrapper.parseLogs("Sale",c?.logs)[0].args.firstPurchasedTokenId,C=g.add(r),b=[];for(let w=g;w.lt(C);w=w.add(1))b.push({id:w,receipt:c,data:()=>this.erc721.get(w)});return b}),d});async getSaleDetails(){return this.contractWrapper.read("saleDetails",[])}}class Rt{featureName=L.name;constructor(t,r){this.erc721=t,this.contractWrapper=r}async getClaimTransaction(t,r,a){let e={};return a&&a.pricePerToken&&(e=await ft(this.contractWrapper,a.pricePerToken,r,a.currencyAddress,a.checkERC20Allowance)),h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[t,r],overrides:e})}to=p(async(t,r,a)=>{const e=await this.getClaimTransaction(t,r,a);return e.setParse(n=>{const i=this.contractWrapper.parseLogs("TokensClaimed",n?.logs)[0].args.startTokenId,o=i.add(r),d=[];for(let c=i;c.lt(o);c=c.add(1))d.push({id:c,receipt:n,data:()=>this.erc721.get(c)});return d}),e})}class Ft{featureName=J.name;constructor(t,r,a){this.erc721=t,this.contractWrapper=r,this.storage=a,this.revealer=this.detectErc721Revealable()}lazyMint=p(async(t,r)=>{const a=await this.erc721.nextTokenIdToMint(),e=await P(t,this.storage,a.toNumber(),r),n=I(e);return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[e.length,n.endsWith("/")?n:`${n}/`,A("")],parse:s=>{const i=this.contractWrapper.parseLogs("TokensLazyMinted",s?.logs),o=i[0].args.startTokenId,d=i[0].args.endTokenId,c=[];for(let m=o;m.lte(d);m=m.add(1))c.push({id:m,receipt:s,data:()=>this.erc721.getTokenMetadata(m)});return c}})});detectErc721Revealable(){if(l(this.contractWrapper,"ERC721Revealable"))return new Et(this.contractWrapper,this.storage,X.name,()=>this.erc721.nextTokenIdToMint())}}class Lt{featureName=F.name;constructor(t){this.contractWrapper=t}cancel=p(async t=>h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancel",args:[t]}));revoke=p(async t=>h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"revoke",args:[t]}))}class _t{featureName=G.name;constructor(t,r){this.contractWrapper=t,this.storage=r}update=p(async(t,r)=>{const a=await V(r,this.storage);return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setTokenURI",args:[t,a]})})}class Ut{featureName=Q.name;constructor(t,r,a){this.erc721=t,this.contractWrapper=r,this.storage=a}to=p(async(t,r)=>{const[a,e]=await Promise.all([P(r,this.storage),W(t)]),n=new rt(this.contractWrapper),s=a.map(i=>n.encode("mintTo",[e,i]));return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[s],parse:i=>{const o=this.contractWrapper.parseLogs("TokensMinted",i.logs);if(o.length===0||o.length<r.length)throw new Error("TokenMinted event not found, minting failed");return o.map(d=>{const c=d.args.tokenIdMinted;return{id:c,receipt:i,data:()=>this.erc721.get(c)}})}})})}class Bt{featureName=$.name;constructor(t,r,a){this.erc721=t,this.contractWrapper=r,this.storage=a,this.batch=this.detectErc721BatchMintable()}to=p(async(t,r)=>{const[a,e]=await Promise.all([V(r,this.storage),W(t)]);return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[e,a],parse:n=>{const s=this.contractWrapper.parseLogs("Transfer",n?.logs);if(s.length===0)throw new Error("TransferEvent event not found");const i=s[0].args.tokenId;return{id:i,receipt:n,data:()=>this.erc721.get(i)}}})});async getMintTransaction(t,r){return this.to.prepare(await W(t),r)}detectErc721BatchMintable(){if(l(this.contractWrapper,"ERC721BatchMintable"))return new Ut(this.erc721,this.contractWrapper,this.storage)}}class xt{featureName=q.name;constructor(t,r){this.contractWrapper=t,this.storage=r}async get(){const t=await this.contractWrapper.read("sharedMetadata",[]);if(!t.every(r=>r===""))return{name:t.name,description:t.description,image:t.imageURI,animation_url:t.animationURI}}set=p(async t=>{const r=Ct.parse(t);r.description=this.sanitizeJSONString(r.description);const a=[];O(r.image)?a.push(this.storage.upload(r.image)):typeof r.image=="string"?a.push(Promise.resolve(r.image)):a.push(Promise.resolve(void 0)),O(r.animation_url)?a.push(this.storage.upload(r.animation_url)):typeof r.animation_url=="string"?a.push(Promise.resolve(r.animation_url)):a.push(Promise.resolve(void 0));const[e,n]=await Promise.all(a);return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setSharedMetadata",args:[{name:`${r.name||""}`,description:r.description||"",imageURI:e||"",animationURI:n||""}]})});sanitizeJSONString(t){if(!t)return t;const r=JSON.stringify(t);return r.slice(1,r.length-1)}}class Ot{featureName=ut.name;constructor(t,r){this.erc721=t,this.contractWrapper=r}async all(t,r){let a=await this.tokenIds(t);if(r){const e=r?.start||0,n=r?.count||N;a=a.slice(e,e+n)}return await Promise.all(a.map(e=>this.erc721.get(e.toString())))}async tokenIds(t){const r=await W(t||await this.contractWrapper.getSignerAddress()),a=await this.contractWrapper.read("balanceOf",[r]),e=Array.from(Array(a.toNumber()).keys());return await Promise.all(e.map(n=>this.contractWrapper.read("tokenOfOwnerByIndex",[r,n])))}}class Dt{featureName=mt.name;constructor(t,r){this.erc721=t,this.contractWrapper=r}async all(t,r){let a=await this.tokenIds(t);if(r){const e=r?.start||0,n=r?.count||N;a=a.slice(e,e+n)}return await Promise.all(a.map(e=>this.erc721.get(e.toString())))}async tokenIds(t){const r=await W(t||await this.contractWrapper.getSignerAddress());return await this.contractWrapper.read("tokensOfOwner",[r])}}class zt{featureName=M.name;constructor(t,r){this.erc721=t,this.contractWrapper=r,this.owned=this.detectErc721Owned()}async all(t){let r=f.from(0);T("startTokenId",this.contractWrapper)&&(r=await this.contractWrapper.read("startTokenId",[]));const a=f.from(t?.start||0).add(r).toNumber(),e=f.from(t?.count||N).toNumber(),n=await this.erc721.nextTokenIdToMint(),s=Math.min(n.add(r).toNumber(),a+e);return await Promise.all([...Array(s-a).keys()].map(i=>this.erc721.get((a+i).toString())))}async allOwners(){let t,r=f.from(0);T("startTokenId",this.contractWrapper)&&(r=await this.contractWrapper.read("startTokenId",[]));try{t=await this.erc721.totalClaimedSupply()}catch{t=await this.totalCount()}t=t.add(r);const a=[...new Array(t.toNumber()).keys()],e=await Promise.all(a.map(n=>this.erc721.ownerOf(n).catch(()=>k)));return a.map(n=>({tokenId:n,owner:e[n]})).filter(n=>n.owner!==k)}async totalCount(){return await this.erc721.nextTokenIdToMint()}async totalCirculatingSupply(){return await this.contractWrapper.read("totalSupply",[])}detectErc721Owned(){if(l(this.contractWrapper,"ERC721Enumerable"))return new Ot(this.erc721,this.contractWrapper);if(l(this.contractWrapper,"ERC721AQueryable"))return new Dt(this.erc721,this.contractWrapper)}}const Zt=At.extend({tierPriority:z.array(z.string()),royaltyRecipient:gt.default(k),royaltyBps:yt.default(0),quantity:Wt.default(1)}),Vt=[{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"},{name:"data",type:"bytes"}];class $t{featureName=j.name;constructor(t,r,a){this.erc721=t,this.contractWrapper=r,this.storage=a}async getMetadataInTier(t){const a=(await this.contractWrapper.read("getMetadataForAllTiers",[])).find(n=>n.tier===t);if(!a)throw new Error("Tier not found in contract.");return await Promise.all(a.ranges.map((n,s)=>{const i=[],o=a.baseURIs[s];for(let d=n.startIdInclusive.toNumber();d<n.endIdNonInclusive.toNumber();d++){const c=o.endsWith("/")?`${o}${d}`:`${o}/${d}`,m=this.storage.downloadJSON(c);i.push(m)}return i}).flat())}async getTokensInTier(t){const r=await this.contractWrapper.read("getTokensInTierLen",[]);if(r.eq(0))return[];const a=await this.contractWrapper.read("getTokensInTier",[t,0,r]);return await Promise.all(a.map(n=>{const s=[];for(let i=n.startIdInclusive.toNumber();i<n.endIdNonInclusive.toNumber();i++)s.push(this.erc721.get(i));return s}).flat())}createBatchWithTier=p(async(t,r,a)=>{const e=await this.erc721.nextTokenIdToMint(),n=await P(t,this.storage,e.toNumber(),a),s=I(n);return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[n.length,s.endsWith("/")?s:`${s}/`,r,A("")],parse:i=>{const o=this.contractWrapper.parseLogs("TokensLazyMinted",i?.logs),d=o[0].args[1],c=o[0].args[2],m=[];for(let g=d;g.lte(c);g=g.add(1))m.push({id:g,receipt:i,data:()=>this.erc721.getTokenMetadata(g)});return m}})});createDelayedRevealBatchWithTier=p(async(t,r,a,e,n)=>{if(!a)throw new Error("Password is required");const s=await this.storage.uploadBatch([Z.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),i=I(s),o=await this.erc721.nextTokenIdToMint(),d=await this.storage.uploadBatch(r.map(S=>Z.parse(S)),{onProgress:n?.onProgress,rewriteFileNames:{fileStartNumber:o.toNumber()}}),c=I(d),m=await this.contractWrapper.read("getBaseURICount",[]),g=await this.contractWrapper.getChainID(),C=R(["string","uint256","uint256","address"],[a,g,m,this.contractWrapper.address]),b=await this.contractWrapper.read("encryptDecrypt",[A(c),C]),w=R(["bytes","bytes","uint256"],[A(c),C,g]),at=D.encode(["bytes","bytes32"],[b,w]);return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[d.length,i.endsWith("/")?i:`${i}/`,e,at],parse:S=>{const U=this.contractWrapper.parseLogs("TokensLazyMinted",S?.logs),et=U[0].args[1],nt=U[0].args[2],B=[];for(let E=et;E.lte(nt);E=E.add(1))B.push({id:E,receipt:S,data:()=>this.erc721.getTokenMetadata(E)});return B}})});reveal=p(async(t,r)=>{if(!r)throw new Error("Password is required");const a=await this.contractWrapper.getChainID(),e=R(["string","uint256","uint256","address"],[r,a,t,this.contractWrapper.address]);try{const n=await this.contractWrapper.callStatic().reveal(t,e);if(!n.includes("://")||!n.endsWith("/"))throw new Error("invalid password")}catch{throw new Error("invalid password")}return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})});async generate(t){const[r]=await this.generateBatch([t]);return r}async generateBatch(t){const r=await Promise.all(t.map(n=>Zt.parseAsync(n))),a=await this.contractWrapper.getChainID(),e=this.contractWrapper.getSigner();return tt(e),await Promise.all(r.map(async n=>{const s=await this.contractWrapper.signTypedData(e,{name:"SignatureAction",version:"1",chainId:a,verifyingContract:this.contractWrapper.address},{GenericRequest:Vt},await this.mapPayloadToContractStruct(n));return{payload:n,signature:s.toString()}}))}async verify(t){const r=await this.mapPayloadToContractStruct(t.payload);return(await this.contractWrapper.read("verify",[r,t.signature]))[0]}async claimWithSignature(t){const r=await this.mapPayloadToContractStruct(t.payload),a=await v(this.contractWrapper.getProvider(),t.payload.price,t.payload.currencyAddress),e=await this.contractWrapper.getCallOverrides();await _(this.contractWrapper,a,t.payload.currencyAddress,e);const n=await this.contractWrapper.sendTransaction("claimWithSignature",[r,t.signature],e),s=this.contractWrapper.parseLogs("TokensClaimed",n?.logs),i=s[0].args.startTokenId,o=i.add(s[0].args.quantityClaimed),d=[];for(let c=i;c.lt(o);c=c.add(1))d.push({id:c,receipt:n,data:()=>this.erc721.get(c)});return d}async mapPayloadToContractStruct(t){const r=await v(this.contractWrapper.getProvider(),t.price,t.currencyAddress),a=D.encode(["string[]","address","address","uint256","address","uint256","uint256","address"],[t.tierPriority,t.to,t.royaltyRecipient,t.royaltyBps,t.primarySaleRecipient,t.quantity,r,t.currencyAddress]);return{uid:t.uid,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,data:a}}}class Qt{featureName=K.name;constructor(t,r){this.contractWrapper=t,this.storage=r}mint=p(async t=>{const r=t.payload,a=t.signature,e=await this.contractWrapper.getCallOverrides(),n=s=>{const i=this.contractWrapper.parseLogs("TokensMintedWithSignature",s.logs);if(i.length===0)throw new Error("No MintWithSignature event found");return{id:i[0].args.tokenIdMinted,receipt:s}};if(await this.isLegacyNFTContract()){const s=await this.mapLegacyPayloadToContractStruct(r),i=s.price;return await _(this.contractWrapper,i,r.currencyAddress,e),h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[s,a],overrides:e,parse:n})}else{const s=await this.mapPayloadToContractStruct(r),i=s.pricePerToken.mul(s.quantity);return await _(this.contractWrapper,i,r.currencyAddress,e),h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[s,a],overrides:e,parse:n})}});mintBatch=p(async t=>{const r=await this.isLegacyNFTContract(),a=(await Promise.all(t.map(s=>r?this.mapLegacyPayloadToContractStruct(s.payload):this.mapPayloadToContractStruct(s.payload)))).map((s,i)=>{const o=t[i],d=o.signature,c=o.payload.price;if(f.from(c).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:s,signature:d}}),e=new rt(this.contractWrapper),n=a.map(s=>r?e.encode("mintWithSignature",[s.message,s.signature]):e.encode("mintWithSignature",[s.message,s.signature]));if(T("multicall",this.contractWrapper))return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[n],parse:s=>{const i=this.contractWrapper.parseLogs("TokensMintedWithSignature",s.logs);if(i.length===0)throw new Error("No MintWithSignature event found");return i.map(o=>({id:o.args.tokenIdMinted,receipt:s}))}});throw new Error("Multicall not available on this contract!")});async verify(t){const r=await this.isLegacyNFTContract(),a=t.payload,e=t.signature;let n,s;return r?(n=await this.mapLegacyPayloadToContractStruct(a),s=await this.contractWrapper.read("verify",[n,e])):(n=await this.mapPayloadToContractStruct(a),s=await this.contractWrapper.read("verify",[n,e])),s[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){const r=await this.isLegacyNFTContract(),a=await Promise.all(t.map(o=>bt.parseAsync(o))),e=a.map(o=>o.metadata),n=await P(e,this.storage),s=await this.contractWrapper.getChainID(),i=this.contractWrapper.getSigner();return tt(i),await Promise.all(a.map(async(o,d)=>{const c=n[d],m=await St.parseAsync({...o,uri:c});let g;return r?g=await this.contractWrapper.signTypedData(i,{name:"TokenERC721",version:"1",chainId:s,verifyingContract:this.contractWrapper.address},{MintRequest:It},await this.mapLegacyPayloadToContractStruct(m)):g=await this.contractWrapper.signTypedData(i,{name:"SignatureMintERC721",version:"1",chainId:s,verifyingContract:await this.contractWrapper.address},{MintRequest:Mt},await this.mapPayloadToContractStruct(m)),{payload:m,signature:g.toString()}}))}async mapPayloadToContractStruct(t){const r=await v(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient,uri:t.uri,quantity:t.quantity,pricePerToken:r,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid}}async mapLegacyPayloadToContractStruct(t){const r=await v(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,price:r,uri:t.uri,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}async isLegacyNFTContract(){return l(this.contractWrapper,"ERC721SignatureMintV1")}}class tr{featureName=ct.name;get chainId(){return this._chainId}constructor(t,r,a){this.contractWrapper=t,this.storage=r,this.query=this.detectErc721Enumerable(),this.mintable=this.detectErc721Mintable(),this.burnable=this.detectErc721Burnable(),this.lazyMintable=this.detectErc721LazyMintable(),this.tieredDropable=this.detectErc721TieredDrop(),this.signatureMintable=this.detectErc721SignatureMintable(),this.claimWithConditions=this.detectErc721ClaimableWithConditions(),this.claimCustom=this.detectErc721Claimable(),this.claimZora=this.detectErc721ClaimableZora(),this.erc721SharedMetadata=this.detectErc721SharedMetadata(),this.loyaltyCard=this.detectErc721LoyaltyCard(),this.updatableMetadata=this.detectErc721UpdatableMetadata(),this._chainId=a}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){const[r,a]=await Promise.all([this.ownerOf(t).catch(()=>k),this.getTokenMetadata(t).catch(()=>({id:t.toString(),uri:"",...st}))]);return{owner:r,metadata:a,type:"ERC721",supply:"1"}}async ownerOf(t){return await this.contractWrapper.read("ownerOf",[t])}async balanceOf(t){return await this.contractWrapper.read("balanceOf",[await W(t)])}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async isApproved(t,r){const[a,e]=await Promise.all([W(t),W(r)]);return await this.contractWrapper.read("isApprovedForAll",[a,e])}transfer=p(async(t,r)=>{const[a,e]=await Promise.all([this.contractWrapper.getSignerAddress(),W(t)]);return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[a,e,r]})});transferFrom=p(async(t,r,a)=>{const[e,n]=await Promise.all([W(t),W(r)]);return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom(address,address,uint256)",args:[e,n,a]})});setApprovalForAll=p(async(t,r)=>h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[await W(t),r]}));setApprovalForToken=p(async(t,r)=>h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:[await W(t),r]}));async getAll(t){return y(this.query,M).all(t)}async getAllOwners(){return y(this.query,M).allOwners()}async totalCount(){return this.nextTokenIdToMint()}async totalCirculatingSupply(){return y(this.query,M).totalCirculatingSupply()}async getOwned(t,r){if(t&&(t=await W(t)),this.query?.owned)return this.query.owned.all(t,r);{const[a,e]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners()]);let n=(e||[]).filter(s=>a?.toLowerCase()===s.owner?.toLowerCase());if(r){const s=r?.start||0,i=r?.count||N;n=n.slice(s,s+i)}return await Promise.all(n.map(async s=>this.get(s.tokenId)))}}async getOwnedTokenIds(t){if(t&&(t=await W(t)),this.query?.owned)return this.query.owned.tokenIds(t);{const[r,a]=await Promise.all([t||this.contractWrapper.getSignerAddress(),this.getAllOwners()]);return(a||[]).filter(e=>r?.toLowerCase()===e.owner?.toLowerCase()).map(e=>f.from(e.tokenId))}}mint=p(async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t));mintTo=p(async(t,r)=>y(this.mintable,$).to.prepare(t,r));async getMintTransaction(t,r){return this.mintTo.prepare(t,r)}mintBatch=p(async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t));mintBatchTo=p(async(t,r)=>y(this.mintable?.batch,Q).to.prepare(t,r));burn=p(async t=>y(this.burnable,Y).token.prepare(t));cancel=p(async t=>y(this.loyaltyCard,F).cancel.prepare(t));revoke=p(async t=>y(this.loyaltyCard,F).revoke.prepare(t));lazyMint=p(async(t,r)=>y(this.lazyMintable,J).lazyMint.prepare(t,r));update=p(async(t,r)=>y(this.updatableMetadata,G).update.prepare(t,r));claim=p(async(t,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,r));claimTo=p(async(t,r,a)=>{const e=this.claimWithConditions,n=this.claimCustom,s=this.claimZora;if(e)return e.to.prepare(t,r,a);if(n)return n.to.prepare(t,r,a);if(s)return s.to.prepare(t,r,a);throw new x(L)});async getClaimTransaction(t,r,a){const e=this.claimWithConditions,n=this.claimCustom;if(e)return e.conditions.getClaimTransaction(t,r,a);if(n)return n.getClaimTransaction(t,r,a);throw new x(L)}async totalClaimedSupply(){const t=this.contractWrapper;if(T("totalMinted",t))return this.contractWrapper.read("totalMinted",[]);if(T("nextTokenIdToClaim",t))return this.contractWrapper.read("nextTokenIdToClaim",[]);throw new Error("No function found on contract to get total claimed supply")}async totalUnclaimedSupply(){const[t,r]=await Promise.all([this.nextTokenIdToMint(),this.totalClaimedSupply()]);return t.sub(r)}get claimConditions(){return y(this.claimWithConditions,H).conditions}get tieredDrop(){return y(this.tieredDropable,j)}get signature(){return y(this.signatureMintable,K)}get revealer(){return y(this.lazyMintable?.revealer,X)}get sharedMetadata(){return y(this.erc721SharedMetadata,q)}async getTokenMetadata(t){const r=await this.contractWrapper.read("tokenURI",[t]);if(!r)throw new ot;return it(t,r,this.storage)}async nextTokenIdToMint(){if(T("nextTokenIdToMint",this.contractWrapper)){let t=await this.contractWrapper.read("nextTokenIdToMint",[]);return T("startTokenId",this.contractWrapper)&&(t=t.sub(await this.contractWrapper.read("startTokenId",[]))),t}else{if(T("totalSupply",this.contractWrapper))return await this.contractWrapper.read("totalSupply",[]);throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint")}}detectErc721Enumerable(){if(l(this.contractWrapper,"ERC721Supply")||T("nextTokenIdToMint",this.contractWrapper))return new zt(this,this.contractWrapper)}detectErc721Mintable(){if(l(this.contractWrapper,"ERC721Mintable"))return new Bt(this,this.contractWrapper,this.storage)}detectErc721Burnable(){if(l(this.contractWrapper,"ERC721Burnable"))return new kt(this.contractWrapper)}detectErc721LazyMintable(){if(l(this.contractWrapper,"ERC721LazyMintable"))return new Ft(this,this.contractWrapper,this.storage)}detectErc721TieredDrop(){if(l(this.contractWrapper,"ERC721TieredDrop"))return new $t(this,this.contractWrapper,this.storage)}detectErc721SignatureMintable(){if(l(this.contractWrapper,"ERC721SignatureMintV1")||l(this.contractWrapper,"ERC721SignatureMintV2"))return new Qt(this.contractWrapper,this.storage)}detectErc721ClaimableWithConditions(){if(l(this.contractWrapper,"ERC721ClaimConditionsV1")||l(this.contractWrapper,"ERC721ClaimConditionsV2")||l(this.contractWrapper,"ERC721ClaimPhasesV1")||l(this.contractWrapper,"ERC721ClaimPhasesV2"))return new vt(this,this.contractWrapper,this.storage)}detectErc721Claimable(){if(l(this.contractWrapper,"ERC721ClaimCustom"))return new Rt(this,this.contractWrapper)}detectErc721ClaimableZora(){if(l(this.contractWrapper,"ERC721ClaimZora"))return new Pt(this,this.contractWrapper)}detectErc721SharedMetadata(){if(l(this.contractWrapper,"ERC721SharedMetadata"))return new xt(this.contractWrapper,this.storage)}detectErc721LoyaltyCard(){if(l(this.contractWrapper,"ERC721LoyaltyCard"))return new Lt(this.contractWrapper)}detectErc721UpdatableMetadata(){if(l(this.contractWrapper,"ERC721UpdatableMetadata"))return new _t(this.contractWrapper,this.storage)}}export{Qt as E,tr as a};
