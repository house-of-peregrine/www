import{al as tt,B as E,s as Z,a1 as D,am as at,J as u,t as l,T as W,q as T,an as S,ao as M,ap as j,aq as P,ar as Y,as as R,at as G,au as K,av as J,aw as rt,ax as v,ay as et,az as N,ai as nt,aA as X,K as it,a9 as L,aB as k,aC as B,aD as st,aE as ot,m as ct,o as pt,aF as lt,aG as ht,aH as dt}from"./Login.jzdBbfpg.js";import{a as C}from"./assertEnabled-55070897.browser.esm.ZCyYilSz.js";import{d as w,h as I,C as ut}from"./contract-appuri-a05d1c9a.browser.esm.9_ui4zcj.js";import{F as mt,a as gt,b as x,D as F,u as yt}from"./QueryParams-c7566bb2.browser.esm.T3gRdMo1.js";import{c as wt,D as ft}from"./contract-owner-87f50baf.browser.esm.sMWIeS40.js";import{S as Ct,b as Wt,M as Et,t as _,l as O,n as U,C as y,c as z,f as bt,p as Tt,d as At,e as V,g as $,u as St,h as Mt,i as Q}from"./index.Bt8VikPk.js";import{s as Pt}from"./setErc20Allowance-832742d0.browser.esm.tejeQ4xQ.js";class vt{constructor(t,a,r){this.storage=r,this.contractWrapper=t,this.metadata=a}async getActive(t,a){const r=await this.get(t),e=await this.metadata.get();return await _(r,0,this.contractWrapper.getProvider(),e.merkle,this.storage,a?.withAllowList||!1)}async get(t,a){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const r=await this.contractWrapper.read("claimCondition",[t]);return O(r)}else if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const r=a!==void 0?a:await this.contractWrapper.read("getActiveClaimConditionId",[t]),e=await this.contractWrapper.read("getClaimConditionById",[t,r]);return O(e)}else if(this.isNewSinglePhaseDrop(this.contractWrapper)){const r=await this.contractWrapper.read("claimCondition",[t]);return U(r)}else if(this.isNewMultiphaseDrop(this.contractWrapper)){const r=a!==void 0?a:await this.contractWrapper.read("getActiveClaimConditionId",[t]),e=await this.contractWrapper.read("getClaimConditionById",[t,r]);return U(e)}else throw new Error("Contract does not support claim conditions")}async getAll(t,a){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const r=await this.contractWrapper.read("claimCondition",[t]),e=r.currentStartId.toNumber(),n=r.count.toNumber(),i=[];for(let s=e;s<e+n;s++)i.push(await this.get(t,s));const c=await this.metadata.get();return Promise.all(i.map(s=>_(s,0,this.contractWrapper.getProvider(),c.merkle,this.storage,a?.withAllowList||!1)))}else return[await this.getActive(t,a)]}async canClaim(t,a,r){return r&&(r=await u(r)),(await this.getClaimIneligibilityReasons(t,a,r)).length===0}async getClaimIneligibilityReasons(t,a,r){const e=[];let n,i;if(r===void 0)try{r=await this.contractWrapper.getSignerAddress()}catch(o){console.warn("failed to get signer address",o)}if(!r)return[y.NoWallet];const c=await u(r);try{i=await this.getActive(t)}catch(o){return k(o,"!CONDITION")||k(o,"no active mint condition")?(e.push(y.NoClaimConditionSet),e):(e.push(y.Unknown),e)}if(i.availableSupply!=="unlimited"&&E.from(i.availableSupply).lt(a))return e.push(y.NotEnoughSupply),e;const p=B(i.merkleRootHash).length>0;let h=null;if(p){if(h=await this.getClaimerProofs(t,c),!h&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return e.push(y.AddressNotAllowed),e;if(h)try{const o=await this.prepareClaim(t,a,!1,c);let m;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(n=await this.contractWrapper.read("getActiveClaimConditionId",[t]),[m]=await this.contractWrapper.read("verifyClaimMerkleProof",[n,c,t,a,o.proofs,o.maxClaimable]),!m)return e.push(y.AddressNotAllowed),e}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([m]=await this.contractWrapper.read("verifyClaimMerkleProof",[t,c,a,{proof:o.proofs,maxQuantityInAllowlist:o.maxClaimable}]),!m)return e.push(y.AddressNotAllowed),e}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[t,c,a,o.currencyAddress,o.price,{proof:o.proofs,quantityLimitPerWallet:o.maxClaimable,currency:o.currencyAddressInProof,pricePerToken:o.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(n=await this.contractWrapper.read("getActiveClaimConditionId",[t]),await this.contractWrapper.read("verifyClaim",[n,c,t,a,o.currencyAddress,o.price,{proof:o.proofs,quantityLimitPerWallet:o.maxClaimable,currency:o.currencyAddressInProof,pricePerToken:o.priceInProof}]))}catch(o){switch(console.warn("Merkle proof verification failed:","reason"in o?o.reason:o),o.reason){case"!Qty":e.push(y.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":e.push(y.WrongPriceOrCurrency);break;case"!MaxSupply":e.push(y.NotEnoughSupply);break;case"cant claim yet":e.push(y.ClaimPhaseNotStarted);break;default:{e.push(y.AddressNotAllowed);break}}return e}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let o=E.from(0),m=z(i.maxClaimablePerWallet,0);try{o=await this.getSupplyClaimedByWallet(t,c)}catch{}if(h&&(m=z(h.maxClaimable,0)),m.gt(0)&&m.lt(o.add(a)))return e.push(y.OverMaxClaimablePerWallet),e;if((!p||p&&!h)&&(m.lte(o)||m.eq(0)))return e.push(y.AddressNotAllowed),e}let[g,d]=[E.from(0),E.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(n=await this.contractWrapper.read("getActiveClaimConditionId",[t]),[g,d]=await this.contractWrapper.read("getClaimTimestamp",[t,n,c])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([g,d]=await this.contractWrapper.read("getClaimTimestamp",[t,c]));const f=E.from(Date.now()).div(1e3);if(g.gt(0)&&f.lt(d))return d.eq(N)?e.push(y.AlreadyClaimed):e.push(y.WaitBeforeNextClaimTransaction),e;if(i.price.gt(0)&&st()){const o=i.price.mul(a),m=this.contractWrapper.getProvider();if(ot(i.currencyAddress))(await m.getBalance(c)).lt(o)&&e.push(y.NotEnoughTokens);else{const A=(await ct(()=>import("./Login.jzdBbfpg.js").then(q=>q.dj),__vite__mapDeps([0,1,2]))).default;(await new pt(m,i.currencyAddress,A,{},this.storage).read("balanceOf",[c])).lt(o)&&e.push(y.NotEnoughTokens)}}return e}async getClaimerProofs(t,a,r){const n=(await this.get(t,r)).merkleRoot;if(B(n).length>0){const c=await this.metadata.get(),s=await u(a);return await bt(s,n.toString(),c.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}else return null}async getSupplyClaimedByWallet(t,a){const r=await u(a);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,r]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("getActiveClaimConditionId",[t]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,e,r])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}set=l((()=>{var t=this;return async function(a,r){let e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;return t.setBatch.prepare([{tokenId:a,claimConditions:r}],e)}})());setBatch=l((()=>{var t=this;return async function(a){let r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;const e={},n=await Promise.all(a.map(async s=>{let{tokenId:p,claimConditions:h}=s,g=h;if(t.isLegacySinglePhaseDrop(t.contractWrapper)){if(r=!0,h.length===0)g=[{startTime:new Date(0),currencyAddress:Z,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:lt([0],32),snapshot:[]}];else if(h.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed")}(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&g.forEach(o=>{if(o.snapshot&&o.snapshot.length>0&&(o.maxClaimablePerWallet===void 0||o.maxClaimablePerWallet==="unlimited"))throw new Error(`maxClaimablePerWallet must be set to a specific value when an allowlist is set.
Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.

ex:
contract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])`);if(o.snapshot&&o.snapshot.length>0&&o.maxClaimablePerWallet?.toString()==="0"&&o.snapshot.map(m=>typeof m=="string"?0:Number(m.maxClaimable?.toString()||0)).reduce((m,A)=>m+A,0)===0)throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")});const{snapshotInfos:d,sortedConditions:f}=await Tt(g,0,t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion());return d.forEach(o=>{e[o.merkleRoot]=o.snapshotUri}),{tokenId:p,sortedConditions:f}})),i=await t.metadata.get(),c=[];for(const s of Object.keys(i.merkle||{}))e[s]=i.merkle[s];if(!At(i.merkle,e)){const s=await t.metadata.parseInputMetadata({...i,merkle:e}),p=await t.metadata._parseAndUploadMetadata(s);if(I("setContractURI",t.contractWrapper)){const h=new T(t.contractWrapper);c.push(h.encode("setContractURI",[p]))}else throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.")}if(n.forEach(s=>{let{tokenId:p,sortedConditions:h}=s;const g=new T(t.contractWrapper);if(t.isLegacySinglePhaseDrop(t.contractWrapper)){const d=new T(t.contractWrapper);c.push(d.encode("setClaimConditions",[p,V(h[0]),r]))}else if(t.isLegacyMultiPhaseDrop(t.contractWrapper))c.push(g.encode("setClaimConditions",[p,h.map(V),r]));else if(t.isNewSinglePhaseDrop(t.contractWrapper))c.push(g.encode("setClaimConditions",[p,$(h[0]),r]));else if(t.isNewMultiphaseDrop(t.contractWrapper))c.push(g.encode("setClaimConditions",[p,h.map($),r]));else throw new Error("Contract does not support claim conditions")}),I("multicall",t.contractWrapper))return W.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[c]});throw new Error("Contract does not support multicall")}})());update=l(async(t,a,r)=>{const e=await this.getAll(t),n=await St(a,r,e);return await this.set.prepare(t,n)});async prepareClaim(t,a,r,e){const n=await u(e||await this.contractWrapper.getSignerAddress());return Mt(n,a,await this.getActive(t),async()=>(await this.metadata.get()).merkle,0,this.contractWrapper,this.storage,r,this.getSnapshotFormatVersion())}async getClaimArguments(t,a,r,e){const n=await u(a);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[n,t,r,e.currencyAddress,e.price,e.proofs,e.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[n,t,r,e.currencyAddress,e.price,{proof:e.proofs,maxQuantityInAllowlist:e.maxClaimable},L("")]:[n,t,r,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,pricePerToken:e.priceInProof,currency:e.currencyAddressInProof},L("")]}async getClaimTransaction(t,a,r,e){if(e?.pricePerToken)throw new Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");const n=await this.prepareClaim(a,r,e?.checkERC20Allowance||!0);return W.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(a,t,r,n),overrides:n.overrides})}isNewSinglePhaseDrop(t){return w(t,"ERC1155ClaimConditionsV2")}isNewMultiphaseDrop(t){return w(t,"ERC1155ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return w(t,"ERC1155ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return w(t,"ERC1155ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?Q.V1:Q.V2}}const H=v.object({address:ht,quantity:dt.default(1)}),Nt=v.union([v.array(v.string()).transform(async b=>await Promise.all(b.map(t=>H.parseAsync({address:t})))),v.array(H)]);class It{featureName=R.name;constructor(t){this.contractWrapper=t}async getClaimTransaction(t,a,r,e){let n={};return e&&e.pricePerToken&&(n=await wt(this.contractWrapper,e.pricePerToken,r,e.currencyAddress,e.checkERC20Allowance)),W.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[await u(t),a,r],overrides:n})}to=l(async(t,a,r,e)=>await this.getClaimTransaction(t,a,r,e))}class Dt{featureName=G.name;constructor(t,a){this.contractWrapper=t,this.storage=a;const r=new ut(this.contractWrapper,et,this.storage);this.conditions=new vt(t,r,this.storage)}to=l(async(t,a,r,e)=>await this.conditions.getClaimTransaction(t,a,r,e))}class Rt{featureName=K.name;constructor(t,a,r){this.contractWrapper=t,this.storage=a,this.roles=r}mint=l(async t=>{const a=t.payload,r=t.signature,[e,n]=await Promise.all([this.mapPayloadToContractStruct(a),this.contractWrapper.getCallOverrides()]);return await Pt(this.contractWrapper,e.pricePerToken.mul(e.quantity),a.currencyAddress,n),W.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[e,r],overrides:n,parse:i=>{const c=this.contractWrapper.parseLogs("TokensMintedWithSignature",i.logs);if(c.length===0)throw new Error("No MintWithSignature event found");return{id:c[0].args.tokenIdMinted,receipt:i}}})});mintBatch=l(async t=>{const a=await Promise.all(t.map(i=>this.mapPayloadToContractStruct(i.payload))),r=t.map((i,c)=>{const s=a[c],p=i.signature,h=i.payload.price;if(E.from(h).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:s,signature:p}}),e=new T(this.contractWrapper),n=r.map(i=>e.encode("mintWithSignature",[i.message,i.signature]));if(I("multicall",this.contractWrapper))return W.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[n],parse:i=>{const c=this.contractWrapper.parseLogs("TokensMintedWithSignature",i.logs);if(c.length===0)throw new Error("No MintWithSignature event found");return c.map(s=>({id:s.args.tokenIdMinted,receipt:i}))}});throw new Error("Multicall not supported on this contract!")});async verify(t){const a=t.payload,r=t.signature,e=await this.mapPayloadToContractStruct(a);return(await this.contractWrapper.read("verify",[e,r]))[0]}async generate(t){const a={...t,tokenId:N};return this.generateFromTokenId(a)}async generateFromTokenId(t){return(await this.generateBatchFromTokenIds([t]))[0]}async generateBatch(t){const a=t.map(r=>({...r,tokenId:N}));return this.generateBatchFromTokenIds(a)}async generateBatchFromTokenIds(t){const a=this.contractWrapper.getSigner();nt(a),await this.roles?.verify(["minter"],await a.getAddress());const r=await Promise.all(t.map(d=>Ct.parseAsync(d))),e=r.map(d=>d.metadata),[n,i,c]=await Promise.all([x(e,this.storage),this.contractWrapper.getChainID(),X(this.contractWrapper.address,this.contractWrapper.getProvider())]),s=await Promise.all(r.map((d,f)=>Wt.parseAsync({...d,uri:n[f]}))),p=await Promise.all(s.map(d=>this.mapPayloadToContractStruct(d))),h=c?.type==="TokenERC1155";return(await Promise.all(p.map(d=>this.contractWrapper.signTypedData(a,{name:h?"TokenERC1155":"SignatureMintERC1155",version:"1",chainId:i,verifyingContract:this.contractWrapper.address},{MintRequest:Et},d)))).map((d,f)=>({payload:s[f],signature:d.toString()}))}async mapPayloadToContractStruct(t){const a=await it(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,tokenId:t.tokenId,uri:t.uri,quantity:t.quantity,pricePerToken:a,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}}class Lt{featureName=P.name;constructor(t){this.contractWrapper=t}tokens=l(async(t,a)=>{const r=await this.contractWrapper.getSignerAddress();return this.from.prepare(r,t,a)});from=l(async(t,a,r)=>W.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await u(t),a,r]}));batch=l(async(t,a)=>{const r=await this.contractWrapper.getSignerAddress();return this.batchFrom.prepare(r,t,a)});batchFrom=l(async(t,a,r)=>W.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnBatch",args:[await u(t),a,r]}))}class xt{featureName=S.name;constructor(t,a){this.erc1155=t,this.contractWrapper=a}async all(t){const a=E.from(t?.start||0).toNumber(),r=E.from(t?.count||F).toNumber(),e=Math.min((await this.totalCount()).toNumber(),a+r);return await Promise.all([...Array(e-a).keys()].map(n=>this.erc1155.get((a+n).toString())))}async totalCount(){return await this.contractWrapper.read("nextTokenIdToMint",[])}async totalCirculatingSupply(t){return await this.contractWrapper.read("totalSupply",[t])}async owned(t,a){const[r,e]=await Promise.all([u(t||await this.contractWrapper.getSignerAddress()),this.contractWrapper.read("nextTokenIdToMint",[])]);let i=(await this.contractWrapper.read("balanceOfBatch",[Array(e.toNumber()).fill(r),Array.from(Array(e.toNumber()).keys())])).map((s,p)=>({tokenId:p,balance:s})).filter(s=>s.balance.gt(0));if(a){const s=a?.start||0,p=a?.count||F;i=i.slice(s,s+p)}return(await Promise.all(i.map(s=>this.erc1155.get(s.tokenId.toString())))).map((s,p)=>({...s,owner:r,quantityOwned:i[p].balance.toString()}))}}class kt{featureName=Y.name;constructor(t,a,r){this.erc1155=t,this.contractWrapper=a,this.storage=r,this.revealer=this.detectErc1155Revealable()}lazyMint=l(async(t,a)=>{const r=await this.erc1155.nextTokenIdToMint(),e=await x(t,this.storage,r.toNumber(),a),n=e[0].substring(0,e[0].lastIndexOf("/"));for(let s=0;s<e.length;s++){const p=e[s].substring(0,e[s].lastIndexOf("/"));if(n!==p)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${n}' but got '${p}'`)}const i=s=>{const p=this.contractWrapper.parseLogs("TokensLazyMinted",s?.logs),h=p[0].args.startTokenId,g=p[0].args.endTokenId,d=[];for(let f=h;f.lte(g);f=f.add(1))d.push({id:f,receipt:s,data:()=>this.erc1155.getTokenMetadata(f)});return d},c=await X(this.contractWrapper.address,this.contractWrapper.getProvider());return this.isLegacyEditionDropContract(this.contractWrapper,c)?W.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[e.length,`${n.endsWith("/")?n:`${n}/`}`],parse:i}):W.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[e.length,`${n.endsWith("/")?n:`${n}/`}`,L("")],parse:i})});detectErc1155Revealable(){if(w(this.contractWrapper,"ERC1155Revealable"))return new ft(this.contractWrapper,this.storage,J.name,()=>this.erc1155.nextTokenIdToMint())}isLegacyEditionDropContract(t,a){return a&&a.type==="DropERC1155"&&a.version<3||!1}}class Bt{featureName=j.name;constructor(t,a,r){this.erc1155=t,this.contractWrapper=a,this.storage=r}to=l(async(t,a)=>{const r=a.map(p=>p.metadata),e=a.map(p=>p.supply),n=await x(r,this.storage),i=await u(t),c=new T(this.contractWrapper),s=await Promise.all(n.map(async(p,h)=>c.encode("mintTo",[i,N,p,e[h]])));return W.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[s],parse:p=>{const h=this.contractWrapper.parseLogs("TokensMinted",p.logs);if(h.length===0||h.length<r.length)throw new Error("TokenMinted event not found, minting failed");return h.map(g=>{const d=g.args.tokenIdMinted;return{id:d,receipt:p,data:()=>this.erc1155.get(d)}})}})})}class Ft{featureName=M.name;constructor(t,a,r){this.erc1155=t,this.contractWrapper=a,this.storage=r,this.batch=this.detectErc1155BatchMintable()}to=l(async(t,a)=>{const r=await this.getMintTransaction(t,a);return r.setParse(e=>{const n=this.contractWrapper.parseLogs("TransferSingle",e?.logs);if(n.length===0)throw new Error("TransferSingleEvent event not found");const i=n[0].args.id;return{id:i,receipt:e,data:()=>this.erc1155.get(i.toString())}}),r});async getMintTransaction(t,a){const r=await yt(a.metadata,this.storage);return W.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await u(t),N,r,a.supply]})}additionalSupplyTo=l(async(t,a,r)=>{const e=await this.erc1155.getTokenMetadata(a);return W.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await u(t),a,e.uri,r],parse:n=>({id:E.from(a),receipt:n,data:()=>this.erc1155.get(a)})})});detectErc1155BatchMintable(){if(w(this.contractWrapper,"ERC1155BatchMintable"))return new Bt(this.erc1155,this.contractWrapper,this.storage)}}class jt{featureName=tt.name;get chainId(){return this._chainId}constructor(t,a,r){this.contractWrapper=t,this.storage=a,this.query=this.detectErc1155Enumerable(),this.mintable=this.detectErc1155Mintable(),this.burnable=this.detectErc1155Burnable(),this.lazyMintable=this.detectErc1155LazyMintable(),this.signatureMintable=this.detectErc1155SignatureMintable(),this.claimCustom=this.detectErc1155Claimable(),this.claimWithConditions=this.detectErc1155ClaimableWithConditions(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){const[a,r]=await Promise.all([this.contractWrapper.read("totalSupply",[t]).catch(()=>E.from(0)),this.getTokenMetadata(t).catch(()=>({id:t.toString(),uri:"",...mt}))]);return{owner:Z,metadata:r,type:"ERC1155",supply:a.toString()}}async totalSupply(t){if(w(this.contractWrapper,"ERC1155Supply"))return await this.contractWrapper.read("totalSupply",[t]);throw new D(at)}async balanceOf(t,a){return await this.contractWrapper.read("balanceOf",[await u(t),a])}async balance(t){return await this.balanceOf(await this.contractWrapper.getSignerAddress(),t)}async isApproved(t,a){return await this.contractWrapper.read("isApprovedForAll",[await u(t),await u(a)])}transfer=l((()=>{var t=this;return async function(a,r,e){let n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:[0];const i=await t.contractWrapper.getSignerAddress();return W.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeTransferFrom",args:[i,await u(a),r,e,n]})}})());transferFrom=l((()=>{var t=this;return async function(a,r,e,n){let i=arguments.length>4&&arguments[4]!==void 0?arguments[4]:[0];return W.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeTransferFrom",args:[await u(a),await u(r),e,n,i]})}})());setApprovalForAll=l(async(t,a)=>W.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[t,a]}));airdrop=l((()=>{var t=this;return async function(a,r,e){let n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:[0];const i=e?await u(e):await t.contractWrapper.getSignerAddress(),c=await t.balanceOf(i,a),s=await Nt.parseAsync(r),p=s.reduce((d,f)=>E.from(d).add(E.from(f?.quantity||1)),E.from(0));if(c.lt(E.from(p)))throw new Error(`The caller owns ${c.toString()} NFTs, but wants to airdrop ${p.toString()} NFTs.`);const h=new T(t.contractWrapper),g=s.map(d=>{let{address:f,quantity:o}=d;return h.encode("safeTransferFrom",[i,f,a,o,n])});return W.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[g]})}})());async nextTokenIdToMint(){if(I("nextTokenIdToMint",this.contractWrapper))return await this.contractWrapper.read("nextTokenIdToMint",[]);throw new Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint")}async getAll(t){return C(this.query,S).all(t)}async totalCount(){return C(this.query,S).totalCount()}async totalCirculatingSupply(t){return C(this.query,S).totalCirculatingSupply(t)}async getOwned(t,a){return t&&(t=await u(t)),C(this.query,S).owned(t,a)}mint=l(async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t));mintTo=l(async(t,a)=>C(this.mintable,M).to.prepare(t,a));async getMintTransaction(t,a){return C(this.mintable,M).getMintTransaction(t,a)}mintAdditionalSupply=l(async(t,a)=>C(this.mintable,M).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(),t,a));mintAdditionalSupplyTo=l(async(t,a,r)=>C(this.mintable,M).additionalSupplyTo.prepare(t,a,r));mintBatch=l(async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t));mintBatchTo=l(async(t,a)=>C(this.mintable?.batch,j).to.prepare(t,a));burn=l(async(t,a)=>C(this.burnable,P).tokens.prepare(t,a));burnFrom=l(async(t,a,r)=>C(this.burnable,P).from.prepare(t,a,r));burnBatch=l(async(t,a)=>C(this.burnable,P).batch.prepare(t,a));burnBatchFrom=l(async(t,a,r)=>C(this.burnable,P).batchFrom.prepare(t,a,r));lazyMint=l(async(t,a)=>C(this.lazyMintable,Y).lazyMint.prepare(t,a));async getClaimTransaction(t,a,r,e){const n=this.claimWithConditions,i=this.claimCustom;if(n)return n.conditions.getClaimTransaction(t,a,r,e);if(i)return i.getClaimTransaction(t,a,r,e);throw new D(R)}claim=l(async(t,a,r)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,a,r));claimTo=l(async(t,a,r,e)=>{const n=this.claimWithConditions,i=this.claimCustom;if(n)return n.to.prepare(t,a,r,e);if(i)return i.to.prepare(t,a,r,e);throw new D(R)});get claimConditions(){return C(this.claimWithConditions,G).conditions}get signature(){return C(this.signatureMintable,K)}get revealer(){return C(this.lazyMintable?.revealer,J)}async getTokenMetadata(t){const a=await this.contractWrapper.read("uri",[t]);if(!a)throw new rt;return gt(t,a,this.storage)}detectErc1155Enumerable(){if(w(this.contractWrapper,"ERC1155Enumerable"))return new xt(this,this.contractWrapper)}detectErc1155Mintable(){if(w(this.contractWrapper,"ERC1155Mintable"))return new Ft(this,this.contractWrapper,this.storage)}detectErc1155Burnable(){if(w(this.contractWrapper,"ERC1155Burnable"))return new Lt(this.contractWrapper)}detectErc1155LazyMintable(){if(w(this.contractWrapper,"ERC1155LazyMintableV1")||w(this.contractWrapper,"ERC1155LazyMintableV2"))return new kt(this,this.contractWrapper,this.storage)}detectErc1155SignatureMintable(){if(w(this.contractWrapper,"ERC1155SignatureMintable"))return new Rt(this.contractWrapper,this.storage)}detectErc1155Claimable(){if(w(this.contractWrapper,"ERC1155ClaimCustom"))return new It(this.contractWrapper)}detectErc1155ClaimableWithConditions(){if(w(this.contractWrapper,"ERC1155ClaimConditionsV1")||w(this.contractWrapper,"ERC1155ClaimConditionsV2")||w(this.contractWrapper,"ERC1155ClaimPhasesV1")||w(this.contractWrapper,"ERC1155ClaimPhasesV2"))return new Dt(this.contractWrapper,this.storage)}}export{vt as D,Rt as E,jt as a};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["_astro/Login.jzdBbfpg.js","_astro/index.hfxd0CuE.js","_astro/tokens.Ppa7r3iO.js"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
