import{J as C,ba as y,aH as R,aB as W,aC as P,B as w,az as T,aD as B,aE as F,m as U,o as _,t as A,s as O,aF as V,q as f,T as b,a9 as D}from"./Login.kXXM0ZeX.js";import{t as v,l as S,n as E,C as n,c as N,f as Q,p as H,d as Z,e as k,g as M,u as j,h as z,i as x}from"./index.O_CxpveW.js";import{h as L,d as u}from"./contract-appuri-a05d1c9a.browser.esm.Klf82i5D.js";class ${constructor(t,r,e){this.storage=e,this.contractWrapper=t,this.metadata=r}async getActive(t){const[r,e,i]=await Promise.all([this.get(),this.metadata.get(),this.getTokenDecimals()]);return await v(r,i,this.contractWrapper.getProvider(),e.merkle||{},this.storage,t?.withAllowList||!1)}async get(t){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const r=await this.contractWrapper.read("claimCondition",[]);return S(r)}else if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const r=t!==void 0?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),e=await this.contractWrapper.read("getClaimConditionById",[r]);return S(e)}else if(this.isNewSinglePhaseDrop(this.contractWrapper)){const r=await this.contractWrapper.read("claimCondition",[]);return E(r)}else if(this.isNewMultiphaseDrop(this.contractWrapper)){const r=t!==void 0?t:await this.contractWrapper.read("getActiveClaimConditionId",[]),e=await this.contractWrapper.read("getClaimConditionById",[r]);return E(e)}else throw new Error("Contract does not support claim conditions")}async getAll(t){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const[r,e]=await this.contractWrapper.read("claimCondition",[]),i=r.toNumber(),l=e.toNumber(),o=[];for(let c=i;c<i+l;c++)o.push(this.get(c));const[p,g,...d]=await Promise.all([this.metadata.get(),this.getTokenDecimals(),...o]);return Promise.all(d.map(c=>v(c,g,this.contractWrapper.getProvider(),p.merkle,this.storage,t?.withAllowList||!1)))}else return[await this.getActive(t)]}async canClaim(t,r){return r&&(r=await C(r)),(await this.getClaimIneligibilityReasons(t,r)).length===0}async getClaimIneligibilityReasons(t,r){const e=[];let i,l;if(r===void 0)try{r=await this.contractWrapper.getSignerAddress()}catch(a){console.warn("failed to get signer address",a)}if(!r)return[n.NoWallet];const[o,p]=await Promise.all([C(r),this.getTokenDecimals()]),g=y(R.parse(t),p);try{l=await this.getActive()}catch(a){return W(a,"!CONDITION")||W(a,"no active mint condition")?(e.push(n.NoClaimConditionSet),e):(console.warn("failed to get active claim condition",a),e.push(n.Unknown),e)}if(l.availableSupply!=="unlimited"&&y(l.availableSupply,p).lt(g))return e.push(n.NotEnoughSupply),e;const c=P(l.merkleRootHash).length>0;let h=null;if(c){if(h=await this.getClaimerProofs(o),!h&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return e.push(n.AddressNotAllowed),e;if(h)try{const a=await this.prepareClaim(t,!1,p,o);let s;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(i=await this.contractWrapper.read("getActiveClaimConditionId",[]),[s]=await this.contractWrapper.read("verifyClaimMerkleProof",[i,o,t,a.proofs,a.maxClaimable]),!s)return e.push(n.AddressNotAllowed),e}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([s]=await this.contractWrapper.read("verifyClaimMerkleProof",[o,t,{proof:a.proofs,maxQuantityInAllowlist:a.maxClaimable}]),!s)return e.push(n.AddressNotAllowed),e}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[o,t,a.currencyAddress,a.price,{proof:a.proofs,quantityLimitPerWallet:a.maxClaimable,currency:a.currencyAddressInProof,pricePerToken:a.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(i=await this.contractWrapper.read("getActiveClaimConditionId",[]),await this.contractWrapper.read("verifyClaim",[i,o,t,a.currencyAddress,a.price,{proof:a.proofs,quantityLimitPerWallet:a.maxClaimable,currency:a.currencyAddressInProof,pricePerToken:a.priceInProof}]))}catch(a){switch(console.warn("Merkle proof verification failed:","reason"in a?a.reason:a),a.reason){case"!Qty":e.push(n.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":e.push(n.WrongPriceOrCurrency);break;case"!MaxSupply":e.push(n.NotEnoughSupply);break;case"cant claim yet":e.push(n.ClaimPhaseNotStarted);break;default:{e.push(n.AddressNotAllowed);break}}return e}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let a=w.from(0),s=N(l.maxClaimablePerWallet,p);try{a=await this.getSupplyClaimedByWallet(o)}catch{}if(h&&(s=N(h.maxClaimable,p)),s.gt(0)&&s.lt(a.add(g)))return e.push(n.OverMaxClaimablePerWallet),e;if((!c||c&&!h)&&(s.lte(a)||s.eq(0)))return e.push(n.AddressNotAllowed),e}if(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)){let[a,s]=[w.from(0),w.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(i=await this.contractWrapper.read("getActiveClaimConditionId",[]),[a,s]=await this.contractWrapper.read("getClaimTimestamp",[i,o])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([a,s]=await this.contractWrapper.read("getClaimTimestamp",[o]));const m=w.from(Date.now()).div(1e3);if(a.gt(0)&&m.lt(s))return s.eq(T)?e.push(n.AlreadyClaimed):e.push(n.WaitBeforeNextClaimTransaction),e}if(l.price.gt(0)&&B()){const a=l.price.mul(w.from(t)),s=this.contractWrapper.getProvider();if(F(l.currencyAddress))(await s.getBalance(o)).lt(a)&&e.push(n.NotEnoughTokens);else{const m=(await U(()=>import("./Login.kXXM0ZeX.js").then(I=>I.dj),__vite__mapDeps([0,1,2]))).default;(await new _(s,l.currencyAddress,m,{},this.storage).read("balanceOf",[o])).lt(a)&&e.push(n.NotEnoughTokens)}}return e}async getClaimerProofs(t,r){const i=(await this.get(r)).merkleRoot;if(P(i).length>0){const[o,p]=await Promise.all([this.metadata.get(),C(t)]);return await Q(p,i.toString(),o.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}else return null}async getSupplyClaimedByWallet(t){const r=await C(t);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[r]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("getActiveClaimConditionId",[]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[e,r])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}set=A((()=>{var t=this;return async function(r){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1,i=r;if(t.isLegacySinglePhaseDrop(t.contractWrapper)||t.isNewSinglePhaseDrop(t.contractWrapper)){if(e=!0,r.length===0)i=[{startTime:new Date(0),currencyAddress:O,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:V([0],32),snapshot:[]}];else if(r.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed")}(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&i.forEach(a=>{if(a.snapshot&&a.snapshot.length>0&&(a.maxClaimablePerWallet===void 0||a.maxClaimablePerWallet==="unlimited"))throw new Error(`maxClaimablePerWallet must be set to a specific value when an allowlist is set.
Example: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.
contract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])`);if(a.snapshot&&a.snapshot.length>0&&a.maxClaimablePerWallet?.toString()==="0"&&a.snapshot.map(s=>typeof s=="string"?0:Number(s.maxClaimable?.toString()||0)).reduce((s,m)=>s+m,0)===0)throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")});const{snapshotInfos:l,sortedConditions:o}=await H(i,await t.getTokenDecimals(),t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion()),p={};l.forEach(a=>{p[a.merkleRoot]=a.snapshotUri});const g=await t.metadata.get(),d=[];if(!Z(g.merkle,p)){const a=await t.metadata.parseInputMetadata({...g,merkle:p}),s=await t.metadata._parseAndUploadMetadata(a);if(L("setContractURI",t.contractWrapper)){const m=new f(t.contractWrapper);d.push(m.encode("setContractURI",[s]))}else throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.")}const c=t.contractWrapper,h=new f(c);if(t.isLegacySinglePhaseDrop(c)){const a=new f(c);d.push(a.encode("setClaimConditions",[k(o[0]),e]))}else if(t.isLegacyMultiPhaseDrop(c))d.push(h.encode("setClaimConditions",[o.map(k),e]));else if(t.isNewSinglePhaseDrop(c))d.push(h.encode("setClaimConditions",[M(o[0]),e]));else if(t.isNewMultiphaseDrop(c))d.push(h.encode("setClaimConditions",[o.map(M),e]));else throw new Error("Contract does not support claim conditions");if(L("multicall",t.contractWrapper))return b.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[d]});throw new Error("Contract does not support multicall")}})());update=A(async(t,r)=>{const e=await this.getAll(),i=await j(t,r,e);return await this.set.prepare(i)});async getTokenDecimals(){return u(this.contractWrapper,"ERC20")?this.contractWrapper.read("decimals",[]):Promise.resolve(0)}async prepareClaim(t,r){let e=arguments.length>2&&arguments[2]!==void 0?arguments[2]:0,i=arguments.length>3?arguments[3]:void 0;const[l,o]=await Promise.all([i||this.contractWrapper.getSignerAddress(),this.getActive()]);return z(l,t,o,async()=>(await this.metadata.get()).merkle,e,this.contractWrapper,this.storage,r,this.getSnapshotFormatVersion())}async getClaimArguments(t,r,e){const i=await C(t);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[i,r,e.currencyAddress,e.price,e.proofs,e.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[i,r,e.currencyAddress,e.price,{proof:e.proofs,maxQuantityInAllowlist:e.maxClaimable},D("")]:[i,r,e.currencyAddress,e.price,{proof:e.proofs,quantityLimitPerWallet:e.maxClaimable,pricePerToken:e.priceInProof,currency:e.currencyAddressInProof},D("")]}async getClaimTransaction(t,r,e){if(e?.pricePerToken)throw new Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");const i=await this.prepareClaim(r,e?.checkERC20Allowance===void 0?!0:e.checkERC20Allowance,await this.getTokenDecimals());return b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(t,r,i),overrides:i.overrides})}isNewSinglePhaseDrop(t){return u(t,"ERC721ClaimConditionsV2")||u(t,"ERC20ClaimConditionsV2")}isNewMultiphaseDrop(t){return u(t,"ERC721ClaimPhasesV2")||u(t,"ERC20ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return u(t,"ERC721ClaimConditionsV1")||u(t,"ERC20ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return u(t,"ERC721ClaimPhasesV1")||u(t,"ERC20ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?x.V1:x.V2}}export{$ as D};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["_astro/Login.kXXM0ZeX.js","_astro/index.hfxd0CuE.js","_astro/tokens.xGG2VBAi.js"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
