import{W as J,i as u,_ as l,w as Q,a as I,c as N,j as r,b as s,g as y,k,f as q,S as L,l as b,m as z}from"./Login.jzdBbfpg.js";import{g as K}from"./url-bc88b2b6.browser.esm.hY9mfG0l.js";import"./index.hfxd0CuE.js";import"./tokens.Ppa7r3iO.js";const Y=new Set([1,137,10,42161,56]),j="eip155",x="wagmi.requestedChains",A="wallet_addEthereumChain",S="last-used-chain-id";var a=new WeakMap,_=new WeakMap,p=new WeakMap,P=new WeakSet,E=new WeakSet,M=new WeakSet,f=new WeakSet,W=new WeakSet,D=new WeakSet,U=new WeakSet;class tt extends J{constructor(e){super({...e,options:{isNewChainsStale:!0,...e.options}}),u(this,U),u(this,D),u(this,W),u(this,f),u(this,M),u(this,E),u(this,P),l(this,"id",Q.walletConnect),l(this,"name","WalletConnect"),l(this,"ready",!0),I(this,a,{writable:!0,value:void 0}),I(this,_,{writable:!0,value:void 0}),I(this,p,{writable:!0,value:void 0}),l(this,"onAccountsChanged",i=>{i.length===0?this.emit("disconnect"):i[0]&&this.emit("change",{account:y(i[0])})}),l(this,"onChainChanged",async i=>{const t=Number(i),n=this.isChainUnsupported(t);await s(this,p).setItem(S,String(i)),this.emit("change",{chain:{id:t,unsupported:n}})}),l(this,"onDisconnect",async()=>{await r(this,f,v).call(this,[]),await s(this,p).removeItem(S),this.emit("disconnect")}),l(this,"onDisplayUri",i=>{this.emit("message",{type:"display_uri",data:i})}),l(this,"onConnect",()=>{this.emit("connect",{provider:s(this,a)})}),N(this,p,e.options.storage),r(this,P,O).call(this),this.filteredChains=this.chains.length>50?this.chains.filter(i=>Y.has(i.chainId)):this.chains,this.showWalletConnectModal=this.options.qrcode!==!1}async connect(){let{chainId:e,pairingTopic:i}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};try{let t=e;if(!t){const w=await s(this,p).getItem(S),o=w?parseInt(w):void 0;o&&!this.isChainUnsupported(o)?t=o:t=this.filteredChains[0]?.chainId}if(!t)throw new Error("No chains found on connector.");const n=await this.getProvider();this.setupListeners();const c=await r(this,E,T).call(this);if(n.session&&c&&await n.disconnect(),!n.session||c){const w=this.filteredChains.filter(o=>o.chainId!==t).map(o=>o.chainId);this.emit("message",{type:"connecting"}),await n.connect({pairingTopic:i,chains:[t],optionalChains:w.length>0?w:[t]}),await r(this,f,v).call(this,this.filteredChains.map(o=>{let{chainId:G}=o;return G}))}const d=await n.enable();if(!d[0])throw new Error("No accounts found on provider.");const m=y(d[0]),g=await this.getChainId(),C=this.isChainUnsupported(g);return{account:m,chain:{id:g,unsupported:C},provider:new k(n)}}catch(t){throw/user rejected/i.test(t?.message)?new q(t):t}}async disconnect(){const e=()=>{if(!(typeof localStorage>"u"))for(const n in localStorage)n.startsWith("wc@2")&&localStorage.removeItem(n)};e();const i=await this.getProvider();(async()=>{try{await i.disconnect()}catch(n){if(!/No matching key/i.test(n.message))throw n}finally{r(this,M,R).call(this),await r(this,f,v).call(this,[]),e()}})()}async getAccount(){const{accounts:e}=await this.getProvider();if(!e[0])throw new Error("No accounts found on provider.");return y(e[0])}async getChainId(){const{chainId:e}=await this.getProvider();return e}async getProvider(){let{chainId:e}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(s(this,a)||await r(this,P,O).call(this),e&&await this.switchChain(e),!s(this,a))throw new Error("No provider found.");return s(this,a)}async getSigner(){let{chainId:e}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const[i,t]=await Promise.all([this.getProvider({chainId:e}),this.getAccount()]);return new k(i,e).getSigner(t)}async isAuthorized(){try{const[e,i]=await Promise.all([this.getAccount(),this.getProvider()]),t=await r(this,E,T).call(this);if(!e)return!1;if(t&&i.session){try{await i.disconnect()}catch{}return!1}return!0}catch{return!1}}async switchChain(e){const i=this.chains.find(t=>t.chainId===e);if(!i)throw new L(`Chain with ID: ${e}, not found on connector.`);try{const t=await this.getProvider(),n=r(this,D,V).call(this),c=r(this,U,F).call(this);if(!n.includes(e)&&c.includes(A)){const m=i.explorers&&i.explorers[0],g=m?{blockExplorerUrls:[m.url]}:{};await t.request({method:A,params:[{chainId:b(i.chainId),chainName:i.name,nativeCurrency:i.nativeCurrency,rpcUrls:K(i),...g}]});const C=await r(this,W,H).call(this);C.push(e),await r(this,f,v).call(this,C)}return await t.request({method:"wallet_switchEthereumChain",params:[{chainId:b(e)}]}),i}catch(t){const n=typeof t=="string"?t:t?.message;throw/user rejected request/i.test(n)?new q(t):new L(t)}}async initProvider(){const{default:e,OPTIONAL_EVENTS:i,OPTIONAL_METHODS:t}=await z(()=>import("./index.es.UXYnjcqN.js"),__vite__mapDeps([0,1,2,3])),[n,...c]=this.filteredChains.map(d=>{let{chainId:m}=d;return m});n&&N(this,a,await e.init({showQrModal:this.showWalletConnectModal,projectId:this.options.projectId,optionalMethods:t,optionalEvents:i,chains:[n],optionalChains:c,metadata:{name:this.options.dappMetadata.name,description:this.options.dappMetadata.description||"",url:this.options.dappMetadata.url,icons:[this.options.dappMetadata.logoUrl||""]},rpcMap:Object.fromEntries(this.filteredChains.map(d=>[d.chainId,d.rpc[0]||""])),qrModalOptions:this.options.qrModalOptions}))}async setupListeners(){s(this,a)&&(r(this,M,R).call(this),s(this,a).on("accountsChanged",this.onAccountsChanged),s(this,a).on("chainChanged",this.onChainChanged),s(this,a).on("disconnect",this.onDisconnect),s(this,a).on("session_delete",this.onDisconnect),s(this,a).on("display_uri",this.onDisplayUri),s(this,a).on("connect",this.onConnect))}}async function O(){return s(this,_)||N(this,_,this.initProvider()),s(this,_)}async function T(){if(r(this,U,F).call(this).includes(A)||!this.options.isNewChainsStale)return!1;const e=await r(this,W,H).call(this),i=this.filteredChains.map(n=>{let{chainId:c}=n;return c}),t=r(this,D,V).call(this);return t.length&&!t.some(n=>i.includes(n))?!1:!i.every(n=>e.includes(n))}function R(){s(this,a)&&(s(this,a).removeListener("accountsChanged",this.onAccountsChanged),s(this,a).removeListener("chainChanged",this.onChainChanged),s(this,a).removeListener("disconnect",this.onDisconnect),s(this,a).removeListener("session_delete",this.onDisconnect),s(this,a).removeListener("display_uri",this.onDisplayUri),s(this,a).removeListener("connect",this.onConnect))}async function v(h){await s(this,p).setItem(x,JSON.stringify(h))}async function H(){const h=await s(this,p).getItem(x);return h?JSON.parse(h):[]}function V(){return s(this,a)?s(this,a).session?.namespaces[j]?.chains?.map(e=>parseInt(e.split(":")[1]||""))??[]:[]}function F(){return s(this,a)?s(this,a).session?.namespaces[j]?.methods??[]:[]}export{tt as WalletConnectConnector};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["_astro/index.es.UXYnjcqN.js","_astro/Login.jzdBbfpg.js","_astro/index.hfxd0CuE.js","_astro/tokens.Ppa7r3iO.js"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
