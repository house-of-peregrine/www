import{cr as m,cs as oe,ct as K,a9 as fe,aH as W,b9 as S,aR as q,az as O,ba as E,cu as Y,m as ue,o as le,B as v,aF as z,s as C,K as X,aE as ce,aN as he,I as F,ax as b,aG as G,cv as pe,ae as $,b8 as me,aa as Z,H as de,cw as D,cx as ye,cy as R,cz as ge,cA as V,cB as be}from"./Login.kXXM0ZeX.js";import{b as _,c as we}from"./index.hfxd0CuE.js";import{S as ee,E as Se}from"./assertEnabled-55070897.browser.esm.GpoZczbg.js";import{N as M}from"./setErc20Allowance-832742d0.browser.esm.5FZ1S9fi.js";var xe=function(e){for(var t=new Buffer(e.length),r=0,s=e.length-1;r<=s;++r,--s)t[r]=e[s],t[s]=e[r];return t};const I=_(xe);var te={exports:{}};(function(n,e){(function(t,r){n.exports=r()})(we,function(){function t(f,a){var o=a?"└":"├";return f?o+="─ ":o+="──┐",o}function r(f,a){var o=[];for(var u in f)f.hasOwnProperty(u)&&(a&&typeof f[u]=="function"||o.push(u));return o}function s(f,a,o,u,c,l,h){var d="",y=0,T,p,w=u.slice(0);if(w.push([a,o])&&u.length>0&&(u.forEach(function(g,P){P>0&&(d+=(g[1]?" ":"│")+"  "),!p&&g[0]===a&&(p=!0)}),d+=t(f,o)+f,c&&(typeof a!="object"||a instanceof Date)&&(d+=": "+a),p&&(d+=" (circular ref.)"),h(d)),!p&&typeof a=="object"){var A=r(a,l);A.forEach(function(g){T=++y===A.length,s(g,a[g],T,w,c,l,h)})}}var i={};return i.asLines=function(f,a,o,u){var c=typeof o!="function"?o:!1;s(".",f,!1,[],a,c,u||o)},i.asTree=function(f,a,o){var u="";return s(".",f,!1,[],a,o,function(c){u+=c+`
`}),u},i})})(te);var Te=te.exports;class B{print(){B.print(this)}bufferIndexOf(e,t){if(arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1)return this.binarySearch(e,t,m.Buffer.compare);const s=(i,f)=>i.equals(f);return this.linearSearch(e,t,s)}static binarySearch(e,t,r){let s=0,i=e.length-1;for(;s<=i;){const f=Math.floor((s+i)/2),a=r(e[f],t);if(a===0){for(let o=f-1;o>=0;o--)if(r(e[o],t)!==0)return o+1;return 0}else a<0?s=f+1:i=f-1}return-1}binarySearch(e,t,r){return B.binarySearch(e,t,r)}static linearSearch(e,t,r){for(let s=0;s<e.length;s++)if(r(e[s],t))return s;return-1}linearSearch(e,t,r){return B.linearSearch(e,t,r)}static bufferify(e){if(!m.Buffer.isBuffer(e)){if(typeof e=="object"&&e.words)return m.Buffer.from(e.toString(Be),"hex");if(B.isHexString(e))return m.Buffer.from(e.replace(/^0x/,""),"hex");if(typeof e=="string")return m.Buffer.from(e);if(typeof e=="bigint")return m.Buffer.from(e.toString(16),"hex");if(e instanceof Uint8Array)return m.Buffer.from(e.buffer);if(typeof e=="number"){let t=e.toString();return t.length%2&&(t=`0${t}`),m.Buffer.from(t,"hex")}else if(ArrayBuffer.isView(e))return m.Buffer.from(e.buffer,e.byteOffset,e.byteLength)}return e}bigNumberify(e){return B.bigNumberify(e)}static bigNumberify(e){if(typeof e=="bigint")return e;if(typeof e=="string")return e.startsWith("0x")&&B.isHexString(e)?BigInt("0x"+e.replace("0x","").toString()):BigInt(e);if(m.Buffer.isBuffer(e))return BigInt("0x"+e.toString("hex"));if(e instanceof Uint8Array)return Ce(e);if(typeof e=="number")return BigInt(e);throw new Error("cannot bigNumberify")}static isHexString(e){return typeof e=="string"&&/^(0x)?[0-9A-Fa-f]*$/.test(e)}static print(e){console.log(e.toString())}bufferToHex(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;return B.bufferToHex(e,t)}static bufferToHex(e){return`${(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0)?"0x":""}${(e||m.Buffer.alloc(0)).toString("hex")}`}bufferify(e){return B.bufferify(e)}bufferifyFn(e){return t=>{const r=e(t);if(m.Buffer.isBuffer(r))return r;if(this.isHexString(r))return m.Buffer.from(r.replace("0x",""),"hex");if(typeof r=="string")return m.Buffer.from(r);if(typeof r=="bigint")return m.Buffer.from(t.toString(16),"hex");if(ArrayBuffer.isView(r))return m.Buffer.from(r.buffer,r.byteOffset,r.byteLength);const s=Ae(t.toString("hex")),i=e(s),f=Ie(i);return m.Buffer.from(f,"hex")}}isHexString(e){return B.isHexString(e)}log2(e){return e===1?0:1+this.log2(e/2|0)}zip(e,t){return e.map((r,s)=>[r,t[s]])}static hexZeroPad(e,t){return"0x"+e.replace("0x","").padStart(t,"0")}}var Pe=B;function Be(n){const e=n.words,t=new ArrayBuffer(e.length*4),r=new Uint8Array(t);for(let s=0;s<e.length;s++)r[s*4]=e[s]>>24&255,r[s*4+1]=e[s]>>16&255,r[s*4+2]=e[s]>>8&255,r[s*4+3]=e[s]&255;return t}function Ae(n){const e=new Uint8Array(n.length/2);for(let t=0;t<n.length;t+=2)e[t/2]=parseInt(n.substring(t,t+2),16);return e.buffer}function Ie(n){const e=new Uint8Array(n);return Array.from(e).map(t=>t.toString(16).padStart(2,"0")).join("")}function Ce(n){const e=Array.from(n).map(t=>t.toString(16).padStart(2,"0")).join("");return BigInt(`0x${e}`)}class k extends Pe{duplicateOdd=!1;concatenator=m.Buffer.concat;hashLeaves=!1;isBitcoinTree=!1;leaves=[];layers=[];sortLeaves=!1;sortPairs=!1;sort=!1;fillDefaultHash=null;complete=!1;constructor(e,t){let r=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(super(),r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if(typeof r.fillDefaultHash=="function")this.fillDefaultHash=r.fillDefaultHash;else if(m.Buffer.isBuffer(r.fillDefaultHash)||typeof r.fillDefaultHash=="string")this.fillDefaultHash=(s,i)=>r.fillDefaultHash;else throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:this.fillDefaultHash?.toString()??null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(m.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){for(this.layers=[e];e.length>1;){const t=this.layers.length;this.layers.push([]);const r=this.complete&&t===1&&!Number.isInteger(Math.log2(e.length))?2*e.length-2**Math.ceil(Math.log2(e.length)):e.length;for(let s=0;s<e.length;s+=2){if(s>=r){this.layers[t].push(...e.slice(r));break}else if(s+1===e.length&&e.length%2===1){const u=e[e.length-1];let c=u;if(this.isBitcoinTree){c=this.hashFn(this.concatenator([I(u),I(u)])),c=I(this.hashFn(c)),this.layers[t].push(c);continue}else if(!this.duplicateOdd){this.layers[t].push(e[s]);continue}}const i=e[s],f=s+1===e.length?i:e[s+1];let a=null;this.isBitcoinTree?a=[I(i),I(f)]:a=[i,f],this.sortPairs&&a.sort(m.Buffer.compare);let o=this.hashFn(this.concatenator(a));this.isBitcoinTree&&(o=I(this.hashFn(o))),this.layers[t].push(o)}e=this.layers[t]}}addLeaf(e){(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e){(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(m.Buffer.compare))),this.leaves.filter(t=>this.bufferIndexOf(e,t,this.sortLeaves)!==-1)):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?m.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);const t=this.getLeaves();for(let r=0;r<t.length;r++)if(t[r].equals(e))return r;return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map(e=>this.bufferToHex(e))}static marshalLeaves(e){return JSON.stringify(e.map(t=>k.bufferToHex(t)),null,2)}static unmarshalLeaves(e){let t=null;if(typeof e=="string")t=JSON.parse(e);else if(e instanceof Object)t=e;else throw new Error("Expected type of string or object");if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(k.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce((e,t)=>(Array.isArray(t)?e.push(t.map(r=>this.bufferToHex(r))):e.push(t),e),[])}getLayersFlat(){const e=this.layers.reduce((t,r)=>(Array.isArray(r)?t.unshift(...r):t.unshift(r),t),[]);return e.unshift(m.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map(e=>this.bufferToHex(e))}getLayerCount(){return this.getLayers().length}getRoot(){return this.layers.length===0?m.Buffer.from([]):this.layers[this.layers.length-1][0]||m.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if(typeof e>"u")throw new Error("leaf is required");e=this.bufferify(e);const r=[];if(!Number.isInteger(t)){t=-1;for(let s=0;s<this.leaves.length;s++)m.Buffer.compare(e,this.leaves[s])===0&&(t=s)}if(t<=-1)return[];for(let s=0;s<this.layers.length;s++){const i=this.layers[s],f=t%2,a=f?t-1:this.isBitcoinTree&&t===i.length-1&&s<this.layers.length-1?t:t+1;a<i.length&&r.push({position:f?"left":"right",data:i[a]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map(r=>this.bufferToHex(r.data))}getProofs(){const e=[],t=[];return this.getProofsDFS(this.layers.length-1,0,e,t),t}getProofsDFS(e,t,r,s){const i=t%2;if(e===-1){i||s.push([...r].reverse());return}if(t>=this.layers[e].length)return;const f=this.layers[e],a=i?t-1:t+1;let o=!1;a<f.length&&(o=!0,r.push({position:i?"left":"right",data:f[a]}));const u=t*2,c=t*2+1;this.getProofsDFS(e-1,u,r,s),this.getProofsDFS(e-1,c,r,s),o&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map(e=>this.bufferToHex(e.data))}getPositionalHexProof(e,t){return this.getProof(e,t).map(r=>[r.position==="left"?0:1,this.bufferToHex(r.data)])}getProofIndices(e,t){const r=2**t;let s=new Set;for(const u of e){let c=r+u;for(;c>1;)s.add(c^1),c=c/2|0}const i=e.map(u=>r+u),f=Array.from(s).sort((u,c)=>u-c).reverse();s=i.concat(f);const a=new Set,o=[];for(let u of s)if(!a.has(u))for(o.push(u);u>1&&(a.add(u),!!a.has(u^1));)u=u/2|0;return o.filter(u=>!e.includes(u-r))}getProofIndicesForUnevenTree(e,t){const r=Math.ceil(Math.log2(t)),s=[];for(let a=0;a<r;a++)t%2!==0&&s.push({index:a,leavesCount:t}),t=Math.ceil(t/2);const i=[];let f=e;for(let a=0;a<r;a++){let u=f.map(l=>l%2===0?l+1:l-1).filter(l=>!f.includes(l));const c=s.find(l=>{let{index:h}=l;return h===a});c&&f.includes(c.leavesCount-1)&&(u=u.slice(0,-1)),i.push(u),f=[...new Set(f.map(l=>l%2===0?l/2:l%2===0?(l+1)/2:(l-1)/2))]}return i}getMultiProof(e,t){if(this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat()),this.isUnevenTree()&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let s=t;this.sortPairs&&(s=s.sort(m.Buffer.compare));let i=s.map(u=>this.bufferIndexOf(this.leaves,u,this.sortLeaves)).sort((u,c)=>u===c?0:u>c?1:-1);if(!i.every(u=>u!==-1))throw new Error("Element does not exist in Merkle tree");const f=[],a=[];let o=[];for(let u=0;u<this.layers.length;u++){const c=this.layers[u];for(let l=0;l<i.length;l++){const h=i[l],d=this.getPairNode(c,h);f.push(c[h]),d&&a.push(d),o.push(h/2|0)}i=o.filter((l,h,d)=>d.indexOf(l)===h),o=[]}return a.filter(u=>!f.includes(u))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map(s=>e[s])}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],s=t;for(const i of e){const f=[];for(const o of s){if(o%2===0){const c=o+1;if(!s.includes(c)&&i[c]){f.push(i[c]);continue}}const u=o-1;if(!s.includes(u)&&i[u]){f.push(i[u]);continue}}r=r.concat(f);const a=new Set;for(const o of s){if(o%2===0){a.add(o/2);continue}if(o%2===0){a.add((o+1)/2);continue}a.add((o-1)/2)}s=Array.from(a)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map(r=>this.bufferToHex(r))}getProofFlags(e,t){if(!Array.isArray(e)||e.length<=0)throw new Error("Invalid Inputs!");let r;if(e.every(Number.isInteger)?r=[...e].sort((a,o)=>a===o?0:a>o?1:-1):r=e.map(a=>this.bufferIndexOf(this.leaves,a,this.sortLeaves)).sort((a,o)=>a===o?0:a>o?1:-1),!r.every(a=>a!==-1))throw new Error("Element does not exist in Merkle tree");const s=t.map(a=>this.bufferify(a)),i=[],f=[];for(let a=0;a<this.layers.length;a++){const o=this.layers[a];r=r.reduce((u,c)=>{if(!i.includes(o[c])){const h=this.getPairNode(o,c),d=s.includes(o[c])||s.includes(h);h&&f.push(!d),i.push(o[c]),i.push(h)}return u.push(c/2|0),u},[])}return f}verify(e,t,r){let s=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let i=0;i<e.length;i++){const f=e[i];let a=null,o=null;if(typeof f=="string")a=this.bufferify(f),o=!0;else if(Array.isArray(f))o=f[0]===0,a=this.bufferify(f[1]);else if(m.Buffer.isBuffer(f))a=f,o=!0;else if(f instanceof Object)a=this.bufferify(f.data),o=f.position==="left";else throw new Error("Expected node to be of type string or object");const u=[];this.isBitcoinTree?(u.push(I(s)),u[o?"unshift":"push"](I(a)),s=this.hashFn(this.concatenator(u)),s=I(this.hashFn(s))):this.sortPairs?m.Buffer.compare(s,a)===-1?(u.push(s,a),s=this.hashFn(this.concatenator(u))):(u.push(a,s),s=this.hashFn(this.concatenator(u))):(u.push(s),u[o?"unshift":"push"](a),s=this.hashFn(this.concatenator(u)))}return m.Buffer.compare(s,r)===0}verifyMultiProof(e,t,r,s,i){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(e,t,r,s,i);const a=Math.ceil(Math.log2(s));e=this.bufferify(e),r=r.map(l=>this.bufferify(l)),i=i.map(l=>this.bufferify(l));const o={};for(const[l,h]of this.zip(t,r))o[2**a+l]=h;for(const[l,h]of this.zip(this.getProofIndices(t,a),i))o[l]=h;let u=Object.keys(o).map(l=>Number(l)).sort((l,h)=>l-h);u=u.slice(0,u.length-1);let c=0;for(;c<u.length;){const l=u[c];if(l>=2&&{}.hasOwnProperty.call(o,l^1)){let h=[o[l-l%2],o[l-l%2+1]];this.sortPairs&&(h=h.sort(m.Buffer.compare));const d=h[1]?this.hashFn(this.concatenator(h)):h[0];o[l/2|0]=d,u.push(l/2|0)}c+=1}return!t.length||{}.hasOwnProperty.call(o,1)&&o[1].equals(e)}verifyMultiProofWithFlags(e,t,r,s){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);const i=t.length,f=s.length,a=[];let o=0,u=0,c=0;for(let l=0;l<f;l++){const h=s[l]?o<i?t[o++]:a[u++]:r[c++],d=o<i?t[o++]:a[u++],y=[h,d].sort(m.Buffer.compare);a[l]=this.hashFn(this.concatenator(y))}return m.Buffer.compare(a[f-1],e)===0}verifyMultiProofForUnevenTree(e,t,r,s,i){e=this.bufferify(e),r=r.map(a=>this.bufferify(a)),i=i.map(a=>this.bufferify(a));const f=this.calculateRootForUnevenTree(t,r,s,i);return e.equals(f)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const e=this.getLayers().map(r=>r.map(s=>this.bufferToHex(s,!1))),t=[];for(let r=0;r<e.length;r++){const s=[];for(let i=0;i<e[r].length;i++){const f={[e[r][i]]:null};if(t.length){f[e[r][i]]={};const a=t.shift(),o=Object.keys(a)[0];if(f[e[r][i]][o]=a[o],t.length){const u=t.shift(),c=Object.keys(u)[0];f[e[r][i]][c]=u[c]}}s.push(f)}t.push(...s)}return t[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){const r=t%2===0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){const e=this.getLayersAsObject();return Te.asTree(e,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(e){const t=e?.length||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,s){const i=this.zip(e,t).sort((l,h)=>{let[d]=l,[y]=h;return d-y}),f=i.map(l=>{let[h]=l;return h}),a=this.getProofIndicesForUnevenTree(f,r);let o=0;const u=[];for(let l=0;l<a.length;l++){const h=a[l],d=o;o+=h.length,u[l]=this.zip(h,s.slice(d,o))}const c=[i];for(let l=0;l<u.length;l++){const h=u[l].concat(c[l]).sort((p,w)=>{let[A]=p,[g]=w;return A-g}).map(p=>{let[,w]=p;return w}),d=c[l].map(p=>{let[w]=p;return w}),y=[...new Set(d.map(p=>p%2===0?p/2:p%2===0?(p+1)/2:(p-1)/2))],T=[];for(let p=0;p<y.length;p++){const w=y[p],A=h[p*2],g=h[p*2+1],P=g?this.hashFn(this.concatenator([A,g])):A;T.push([w,P])}c.push(T)}return c[c.length-1][0][1]}}function Ke(n){return{startTimestamp:n.startTimestamp,maxClaimableSupply:n.maxClaimableSupply,supplyClaimed:n.supplyClaimed,merkleRoot:n.merkleRoot,pricePerToken:n.pricePerToken,currency:n.currency,quantityLimitPerTransaction:n.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:n.waitTimeInSecondsBetweenClaims||0}}function Ge(n){return{startTimestamp:n.startTimestamp,maxClaimableSupply:n.maxClaimableSupply,supplyClaimed:n.supplyClaimed,merkleRoot:n.merkleRoot,pricePerToken:n.pricePerToken,currency:n.currency,quantityLimitPerWallet:n.maxClaimablePerWallet,metadata:n.metadata||""}}function L(n,e){return n==="unlimited"?O:E(n,e)}async function re(n){const t=Array.from({length:Math.ceil(n.length/25e3)},(i,f)=>n.slice(f*25e3,f*25e3+25e3)),r=[],s=await Promise.all(t.map(i=>V.parseAsync(i)));for(const i of s)r.push(...i);return r}const ve=2;let j=function(n){return n[n.V1=1]="V1",n[n.V2=2]="V2",n}({});class x{constructor(e,t,r,s,i){this.storage=e,this.shardNybbles=s,this.baseUri=t,this.originalEntriesUri=r,this.tokenDecimals=i,this.shards={},this.trees={}}static async fromUri(e,t){try{const r=await t.downloadJSON(e);if(r.isShardedMerkleTree)return x.fromShardedMerkleTreeInfo(r,t)}catch{return}}static async fromShardedMerkleTreeInfo(e,t){return new x(t,e.baseUri,e.originalEntriesUri,e.shardNybbles,e.tokenDecimals)}static hashEntry(e,t,r,s){switch(s){case j.V1:return Z(["address","uint256"],[e.address,L(e.maxClaimable,t)]);case j.V2:return Z(["address","uint256","uint256","address"],[e.address,L(e.maxClaimable,t),L(e.price||"unlimited",r),e.currencyAddress||C])}}static async fetchAndCacheDecimals(e,t,r){if(!r)return 18;let s=e[r];return s===void 0&&(s=(await de(t,r)).decimals,e[r]=s),s}static async buildAndUpload(e,t,r,s,i){let f=arguments.length>5&&arguments[5]!==void 0?arguments[5]:ve;const a=await re(e),o={};for(const g of a){const P=g.address.slice(2,2+f).toLowerCase();o[P]===void 0&&(o[P]=[]),o[P].push(g)}const u={},c=await Promise.all(Object.entries(o).map(async g=>{let[P,U]=g;return[P,new k(await Promise.all(U.map(async H=>{const ie=await x.fetchAndCacheDecimals(u,r,H.currencyAddress);return x.hashEntry(H,t,ie,i)})),D,{sort:!0}).getHexRoot()]})),l=Object.fromEntries(c),h=new k(Object.values(l),D,{sort:!0}),d=[];for(const[g,P]of Object.entries(o)){const U={proofs:h.getProof(l[g]).map(H=>"0x"+H.data.toString("hex")),entries:P};d.push({data:JSON.stringify(U),name:`${g}.json`})}const y=await s.uploadBatch(d),T=y[0].slice(0,y[0].lastIndexOf("/")),p=await s.upload(a),w={merkleRoot:h.getHexRoot(),baseUri:T,originalEntriesUri:p,shardNybbles:f,tokenDecimals:t,isShardedMerkleTree:!0},A=await s.upload(w);return{shardedMerkleInfo:w,uri:A}}async getProof(e,t,r){const s=e.slice(2,2+this.shardNybbles).toLowerCase();let i=this.shards[s];const f={};if(i===void 0)try{const l=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;i=this.shards[s]=await this.storage.downloadJSON(`${l}${s}.json`);const h=await Promise.all(i.entries.map(async d=>{const y=await x.fetchAndCacheDecimals(f,t,d.currencyAddress);return x.hashEntry(d,this.tokenDecimals,y,r)}));this.trees[s]=new k(h,D,{sort:!0})}catch{return null}const a=i.entries.find(l=>l.address.toLowerCase()===e.toLowerCase());if(!a)return null;const o=await x.fetchAndCacheDecimals(f,t,a.currencyAddress),u=x.hashEntry(a,this.tokenDecimals,o,r),c=this.trees[s].getProof(u).map(l=>"0x"+l.data.toString("hex"));return ye.parseAsync({...a,proof:c.concat(i.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(e){return console.warn("Could not fetch original snapshot entries",e),[]}}}async function ke(n,e,t,r,s,i){if(!t)return null;const f=t[e];if(f){const a=await s.downloadJSON(f);if(a.isShardedMerkleTree&&a.merkleRoot===e)return await(await x.fromShardedMerkleTreeInfo(a,s)).getProof(n,r,i);const o=await Y.parseAsync(a);if(e===o.merkleRoot)return o.claims.find(u=>u.address.toLowerCase()===n.toLowerCase())||null}return null}function Ze(n){return{startTimestamp:n.startTimestamp,maxClaimableSupply:n.maxClaimableSupply,supplyClaimed:n.supplyClaimed,merkleRoot:n.merkleRoot.toString(),pricePerToken:n.pricePerToken,currency:n.currency,maxClaimablePerWallet:n.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:n.waitTimeInSecondsBetweenClaims}}function Ye(n){return{startTimestamp:n.startTimestamp,maxClaimableSupply:n.maxClaimableSupply,supplyClaimed:n.supplyClaimed,merkleRoot:n.merkleRoot.toString(),pricePerToken:n.pricePerToken,currency:n.currency,maxClaimablePerWallet:n.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:n.metadata}}async function Le(n,e,t,r,s){const i=n.getSigner(),f=n.getProvider(),a=(await ue(()=>import("./Login.kXXM0ZeX.js").then(d=>d.dj),__vite__mapDeps([0,1,2]))).default,o=new le(i||f,e,a,n.options,n.storage),u=await n.getSignerAddress(),c=n.address,l=await o.read("allowance",[u,c]),h=v.from(t).mul(v.from(r)).div(E("1",s));l.lt(h)&&await o.sendTransaction("approve",[c,l.add(h)])}async function Xe(n,e,t,r,s,i,f,a,o){let u=L(t.maxClaimablePerWallet,s),c=[z([0],32)],l=t.price,h=t.currencyAddress;try{if(!t.merkleRootHash.toString().startsWith(C)){const p=await ke(n,t.merkleRootHash.toString(),await r(),i.getProvider(),f,o);if(p)c=p.proof,u=p.maxClaimable==="unlimited"?O:E(p.maxClaimable,s),l=p.price===void 0||p.price==="unlimited"?O:await X(i.getProvider(),p.price,p.currencyAddress||C),h=p.currencyAddress||C;else if(o===j.V1)throw new Error("No claim found for this address")}}catch(p){if(p?.message==="No claim found for this address")throw p;console.warn("failed to check claim condition merkle root hash, continuing anyways",p)}const d=await i.getCallOverrides()||{},y=l.toString()!==O.toString()?l:t.price,T=h!==C?h:t.currencyAddress;return y.gt(0)&&(ce(T)?d.value=v.from(y).mul(e).div(E("1",s)):a&&await Le(i,T,y,e,s)),{overrides:d,proofs:c,maxClaimable:u,price:y,currencyAddress:T,priceInProof:l,currencyAddressInProof:h}}const Oe=b.object({name:b.string(),symbol:b.string(),decimals:b.number()}),He=Oe.extend({value:S,displayValue:b.string()}),Ne=b.object({name:b.string().optional()}).catchall(b.unknown()),J=b.object({startTime:ee,currencyAddress:b.string().default($),price:W.default(0),maxClaimableSupply:R,maxClaimablePerWallet:R,waitInSeconds:q.default(0),merkleRootHash:ge.default(z([0],32)),snapshot:b.optional(V).nullable(),metadata:Ne.optional()}),Ee=b.array(J),se=J.extend({availableSupply:R,currentMintSupply:R,currencyMetadata:He.default({value:v.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:S,waitInSeconds:S,startTime:S.transform(n=>new Date(n.toNumber()*1e3)),snapshot:V.optional().nullable()});async function Re(n,e,t,r,s){const i=await re(n),f=i.map(u=>u.address);if(new Set(f).size<f.length)throw new be;const o=await x.buildAndUpload(i,e,t,r,s);return{merkleRoot:o.shardedMerkleInfo.merkleRoot,snapshotUri:o.uri}}function Me(n,e){const t=v.from(n),r=v.from(e);return t.eq(r)?0:t.gt(r)?1:-1}async function Ue(n,e,t,r,s){const i=[];return{inputsWithSnapshots:await Promise.all(n.map(async a=>{if(a.snapshot&&a.snapshot.length>0){const o=await Re(a.snapshot,e,t,r,s);i.push(o),a.merkleRootHash=o.merkleRoot}else a.merkleRootHash=z([0],32);return a})),snapshotInfos:i}}async function De(n,e,t,r){const s=n.currencyAddress===C?$:n.currencyAddress,i=L(n.maxClaimableSupply,e),f=L(n.maxClaimablePerWallet,e);let a;return n.metadata&&(typeof n.metadata=="string"?a=n.metadata:a=await r.upload(n.metadata)),{startTimestamp:n.startTime,maxClaimableSupply:i,supplyClaimed:0,maxClaimablePerWallet:f,pricePerToken:await X(t,n.price,s),currency:s,merkleRoot:n.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:n.waitInSeconds||0,metadata:a}}async function _e(n,e,t,r,s){const{inputsWithSnapshots:i,snapshotInfos:f}=await Ue(n,e,t,r,s),a=await Ee.parseAsync(i),o=(await Promise.all(a.map(u=>De(u,e,t,r)))).sort((u,c)=>Me(u.startTimestamp,c.startTimestamp));return{snapshotInfos:f,sortedConditions:o}}async function Fe(n,e,t){if(!e)return null;const r=e[n];if(r){const s=await t.downloadJSON(r);if(s.isShardedMerkleTree&&s.merkleRoot===n)return(await x.fromUri(r,t))?.getAllEntries()||null;{const i=await Y.parseAsync(s);if(n===i.merkleRoot)return i.claims.map(f=>({address:f.address,maxClaimable:f.maxClaimable,price:f.price,currencyAddress:f.currencyAddress}))}}return null}function N(n,e){return n.toString()===O.toString()?"unlimited":F(n,e)}async function et(n,e,t,r,s,i){const f=await he(t,n.currency,n.pricePerToken),a=N(n.maxClaimableSupply,e),o=N(n.maxClaimablePerWallet,e),u=N(v.from(n.maxClaimableSupply).sub(n.supplyClaimed),e),c=N(n.supplyClaimed,e);let l;return n.metadata&&(l=await s.downloadJSON(n.metadata)),se.parseAsync({startTime:n.startTimestamp,maxClaimableSupply:a,maxClaimablePerWallet:o,currentMintSupply:c,availableSupply:u,waitInSeconds:n.waitTimeInSecondsBetweenClaims?.toString(),price:v.from(n.pricePerToken),currency:n.currency,currencyAddress:n.currency,currencyMetadata:f,merkleRootHash:n.merkleRoot,snapshot:i?await Fe(n.merkleRoot,r,s):void 0,metadata:l})}async function tt(n,e,t){if(n>=t.length)throw Error(`Index out of bounds - got index: ${n} with ${t.length} conditions`);const r=t[n].currencyMetadata.decimals,s=t[n].price,i=F(s,r),f=await J.parseAsync({...t[n],price:i,...e}),a=await se.parseAsync({...f,price:s});return t.map((o,u)=>{let c;u===n?c=a:c=o;const l=F(c.price,r);return{...c,price:l}})}let rt=function(n){return n.NotEnoughSupply="There is not enough supply to claim.",n.AddressNotAllowed="This address is not on the allowlist.",n.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",n.ClaimPhaseNotStarted="Claim phase has not started yet.",n.AlreadyClaimed="You have already claimed the token.",n.WrongPriceOrCurrency="Incorrect price or currency.",n.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",n.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",n.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",n.NoClaimConditionSet="There is no claim condition set.",n.NoWallet="No wallet connected.",n.Unknown="No claim conditions found.",n}({});function je(n){if(n===void 0){const e=Buffer.alloc(16);return oe({},e),K(fe(e.toString("hex")))}else return K(n)}const ne=b.object({to:G.refine(n=>n.toLowerCase()!==C,{message:"Cannot create payload to mint to zero address"}),price:W.default(0),currencyAddress:pe.default($),mintStartTime:ee,mintEndTime:Se,uid:b.string().optional().transform(n=>je(n)),primarySaleRecipient:G.default(C)}),We=ne.extend({quantity:W}),st=We.extend({mintStartTime:S,mintEndTime:S}),Q=ne.extend({metadata:M,royaltyRecipient:b.string().default(C),royaltyBps:me.default(0)}),ae=Q.extend({metadata:M.default(""),uri:b.string(),royaltyBps:S,mintStartTime:S,mintEndTime:S}),qe=Q.extend({metadata:M.default(""),quantity:q}),nt=qe.extend({tokenId:q}),at=ae.extend({tokenId:S,quantity:S}),it=Q.extend({metadata:M.default(""),quantity:S.default(1)}),ot=ae.extend({quantity:S.default(1)}),ft=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ut=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],lt=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ct=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}];var ze=function n(e,t){if(e===t)return!0;if(e&&t&&typeof e=="object"&&typeof t=="object"){if(e.constructor!==t.constructor)return!1;var r,s,i;if(Array.isArray(e)){if(r=e.length,r!=t.length)return!1;for(s=r;s--!==0;)if(!n(e[s],t[s]))return!1;return!0}if(e.constructor===RegExp)return e.source===t.source&&e.flags===t.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===t.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===t.toString();if(i=Object.keys(e),r=i.length,r!==Object.keys(t).length)return!1;for(s=r;s--!==0;)if(!Object.prototype.hasOwnProperty.call(t,i[s]))return!1;for(s=r;s--!==0;){var f=i[s];if(!n(e[f],t[f]))return!1}return!0}return e!==e&&t!==t};const ht=_(ze);export{ne as B,rt as C,lt as M,nt as S,Le as a,at as b,L as c,ht as d,Ke as e,ke as f,Ge as g,Xe as h,j as i,it as j,ot as k,Ze as l,ut as m,Ye as n,ct as o,_e as p,We as q,st as r,ft as s,et as t,tt as u,je as v};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["_astro/Login.kXXM0ZeX.js","_astro/index.hfxd0CuE.js","_astro/tokens.xGG2VBAi.js"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}
